[{"/home/rumec/Documents/BP/BP/visualization/src/index.js":"1","/home/rumec/Documents/BP/BP/visualization/src/App.js":"2","/home/rumec/Documents/BP/BP/visualization/src/reportWebVitals.js":"3","/home/rumec/Documents/BP/BP/visualization/src/components/Chart1.js":"4","/home/rumec/Documents/BP/BP/visualization/src/components/SparseGraphPseudocode.js":"5","/home/rumec/Documents/BP/BP/visualization/src/components/SparseGraphDemoLoading.js":"6","/home/rumec/Documents/BP/BP/visualization/src/components/SparseGraphSubprocedure.js":"7","/home/rumec/Documents/BP/BP/visualization/src/components/SparseGraphDemoStep.js":"8","/home/rumec/Documents/BP/BP/visualization/src/components/DenseGraphPseudocode.js":"9","/home/rumec/Documents/BP/BP/visualization/src/components/DenseGraphSubprocedure.js":"10"},{"size":923,"mtime":1614615520010,"results":"11","hashOfConfig":"12"},{"size":3637,"mtime":1614615520006,"results":"13","hashOfConfig":"12"},{"size":362,"mtime":1614615520010,"results":"14","hashOfConfig":"12"},{"size":45399,"mtime":1620411359172,"results":"15","hashOfConfig":"12"},{"size":3736,"mtime":1619886677932,"results":"16","hashOfConfig":"12"},{"size":522,"mtime":1619886677932,"results":"17","hashOfConfig":"12"},{"size":7864,"mtime":1619886677932,"results":"18","hashOfConfig":"12"},{"size":0,"mtime":1619886677932,"results":"19","hashOfConfig":"12"},{"size":3134,"mtime":1620408566635,"results":"20","hashOfConfig":"12"},{"size":3708,"mtime":1620409990408,"results":"21","hashOfConfig":"12"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},"1hwt9ro",{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"31","usedDeprecatedRules":"24"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"34","usedDeprecatedRules":"24"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"37","messages":"38","errorCount":0,"warningCount":44,"fixableErrorCount":0,"fixableWarningCount":0,"source":"39","usedDeprecatedRules":"24"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"24"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"44","usedDeprecatedRules":"24"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47"},"/home/rumec/Documents/BP/BP/visualization/src/index.js",[],["48","49"],"/home/rumec/Documents/BP/BP/visualization/src/App.js",[],"/home/rumec/Documents/BP/BP/visualization/src/reportWebVitals.js",[],"/home/rumec/Documents/BP/BP/visualization/src/components/Chart1.js",["50"],"import React from \"react\";\nimport Graph from \"react-graph-vis\";\nimport './graphStyle.css';\nimport SparseGraphPseudocode from \"./SparseGraphPseudocode\";\nimport SparseGraphSubprocedure from \"./SparseGraphSubprocedure\";\nimport SparseGraphDemoLoading from \"./SparseGraphDemoLoading\";\nimport SparseGraphDemoStep from \"./SparseGraphDemoStep\";\nimport DenseGraphPseudocode from \"./DenseGraphPseudocode\";\nimport DenseGraphSubprocedure from \"./DenseGraphSubprocedure\";\n//import DFS from \"./DFS\";\n//import SparseGraph from \"./SparseGraph\";\n\nconst RADIUS = 200;\n\nclass NetworkGraph extends React.Component {\n    constructor(props) {\n        super(props);\n        this.visited = [];\n        this.status = {\n            LESS_THAN_DELTA_EDGES: 0,\n            CYCLE_FOUND: 1,\n            MORE_THAN_DELTA_EDGES: 2\n        }\n\n        // inspired by: https://gist.github.com/mucar/3898821\n        this.color = ['#1AB399', '#F16FF1', '#F91AFF', '#06C6FF', '#4DB3FF',\n            '#E6B333', '#3366E6', '#999966', '#99FF99', '#B34D4D',\n            '#80B300', '#809900', '#E6B3B3', '#6680B3', '#66991A',\n            '#FF99E6', '#CCFF1A', '#FF1A66', '#E6331A', '#33FFCC',\n            '#66994D', '#B366CC', '#4D8000', '#B33300', '#CC80CC',\n            '#E666B3', '#33991A', '#CC9999', '#B3B31A', '#00E680',\n            '#4D8066', '#809980', '#E6FF80', '#1AFF33', '#999933',\n            '#FF3380', '#CCCC00', '#66E64D', '#4D80CC', '#9900B3',\n            '#FF6633', '#FFB399', '#FF33FF', '#FFFF99', '#00B3E6',\n            '#E64D66', '#4DB380', '#FF4D4D', '#99E6E6', '#6666FF'];\n\n        this.state = {\n            graphType: \"dense\",\n            sequenceToAdd: [],\n            subprocedure: 0,\n            subprocedureStep: 0,\n            mainProcedureStep: 0,\n            timeoutInput: 500,\n            timeout: 500,\n            followerList: {},\n\n            e_in: {}, // JSON of lists in incoming edges\n            delta: 0,\n\n            inProgress: false,\n            visited: [],\n            addingEdge: false,\n            from: 0,\n            to: 0,\n            numberOfVertices: 0,\n            nodes: [],\n            edges: [],\n            b: [],\n            c: []\n        };\n        this.handleChange = this.handleChange.bind(this);\n        this.generateGraph = this.generateGraph.bind(this);\n        this.addEdge = this.addEdge.bind(this);\n        this.changeVertex = this.changeVertex.bind(this);\n        this.changeEdge = this.changeEdge.bind(this);\n        this.colorGraphToDefault = this.colorGraphToDefault.bind(this);\n        this.changeProgress = this.changeProgress.bind(this);\n        this.addVisitedVertex = this.addVisitedVertex.bind(this);\n        this.clearVisitedVertices = this.clearVisitedVertices.bind(this);\n        this.setTimeoutFromInput = this.setTimeoutFromInput.bind(this);\n        this.addVertexToEin = this.addVertexToEin.bind(this);\n        this.setEinOfVertex = this.setEinOfVertex.bind(this);\n        this.setSubprocedureStep = this.setSubprocedureStep.bind(this);\n        this.changeValue = this.changeValue.bind(this);\n        this.cancelDemo = this.cancelDemo.bind(this);\n        this.step = this.step.bind(this);\n        this.handleDropdownChange = this.handleDropdownChange.bind(this);\n    }\n\n    async changeValue(id, newValue) {\n        await this.setState({\n            [id]: newValue\n        })\n    }\n\n    /**\n     * Sets step of the specified subprocedure for pseudocode animation\n     *\n     * @param subprocedure - Number of subprocedure we want to animate\n     * @param step - Current step in specified subprocedure\n     * @returns {Promise<void>}\n     */\n    async setSubprocedureStep(subprocedure, step) {\n        await this.setState({\n            subprocedure: subprocedure,\n            subprocedureStep: step\n        })\n    }\n\n    /**\n     * Adds a vertex to the e_in set\n     *\n     * @param successor - Vertex which e_in should be expanded\n     * @param predecessor - Vertex to be added\n     * @returns {Promise<void>}\n     */\n    async addVertexToEin(successor, predecessor) {\n        const oldEin = await this.state.e_in;\n        await oldEin[successor].push(predecessor);\n        await this.setState({\n            e_in: oldEin,\n        });\n    }\n\n    /**\n     * Sets the set of incoming edges to be the value given as parameter\n     *\n     * @param vertex - ID of vertex which e_in should be changed\n     * @param toBeSet - New value of e_in\n     * @returns {Promise<void>}\n     */\n    async setEinOfVertex(vertex, toBeSet) {\n        await this.setState(async prevState => {\n            prevState.e_in[vertex] = await toBeSet;\n            return prevState;\n        })\n    }\n\n    /**\n     * Handles changes of the controllers\n     *\n     * @param event - Object returned by event\n     */\n    handleChange(event) {\n        const {name, /*type, */ value/*, checked*/} = event.target;\n\n        //if (name === \"from\" || name === \"to\") {\n        this.setState({\n            [name]: parseInt(value)\n        })\n        //}\n\n        /*\n        (type === \"checkbox\") ? this.setState({[name]: checked})\n            : (name === \"addingEdge\") ? this.setState(prevState => {\n                return {\n                    addingEdge: !prevState.addingEdge\n                }\n            })\n            : this.setState({[name]: value});\n\n         */\n    }\n\n    /**\n     * Changes the actual graph type and also resets the graph properties\n     *\n     * @param event\n     */\n    handleDropdownChange(event) {\n        this.setState({\n            graphType: event.target.value,\n            sequenceToAdd: [],\n            subprocedure: 0,\n            subprocedureStep: 0,\n            mainProcedureStep: 0,\n            timeoutInput: 500,\n            timeout: 500,\n            followerList: {},\n\n            e_in: {}, // JSON of lists in incoming edges\n            delta: 0,\n\n            inProgress: false,\n            visited: [],\n            addingEdge: false,\n            from: 0,\n            to: 0,\n            numberOfVertices: 0,\n            nodes: [],\n            edges: [],\n            b: [],\n            c: []\n        });\n    }\n\n    /**\n     * Generates new graph, sets levels of all vertices to 1\n     *\n     * @returns {Promise<void>}\n     */\n    async generateGraph() {\n        let actualAngle = 0;\n        let nodesArr = [];\n        let bArr = [];\n        let bTmp;\n        let cArr = [];\n        let cTmp;\n        let followerList = {};\n        let e_in = {};\n        await this.setState({\n            //sequenceToAdd: [],\n            nodes: [],\n        })\n        for (let i = 1; i <= this.state.numberOfVertices; ++i) {\n            bTmp = [];\n            cTmp = [];\n            for (let j = 1; j <= this.state.numberOfVertices; ++j) {\n                bTmp.push(1);\n                cTmp.push(0);\n            }\n            bArr.push(bTmp);\n            cArr.push(cTmp);\n            await nodesArr.push({\n                id: i,\n                level: 1,\n                inDegree: 0,\n                label: i.toString() + \", 1\",\n                title: i.toString(),\n                color: this.color[0],\n                x: RADIUS * Math.sin(actualAngle),\n                y: RADIUS * Math.cos(actualAngle)\n            });\n            followerList[i] = [];\n            e_in[i] = []; // initializing list of incoming edges\n            actualAngle += await (2 * Math.PI) / (this.state.numberOfVertices);\n        }\n        await this.setState({\n            mainProcedureStep: 0,\n            followerList: followerList,\n            e_in: e_in,\n            nodes: nodesArr,\n            edges: [],\n            delta: 0,\n            from: 0,\n            to: 0,\n            b: bArr,\n            c: cArr\n        });\n\n        /**\n         * Osetřit jinak!!!\n         */\n        if (this.state.sequenceToAdd.length !== 10) {\n            this.setState({\n                sequenceToAdd: []\n            })\n        }\n    }\n\n    /**\n     * Adds new edge to graph\n     * @param k_out - approximate level of an edge (used as key)\n     * @returns {Promise<void>}\n     */\n    async addEdge(k_out = 1) {\n        const from = parseInt(this.state.from);\n        const to = parseInt(this.state.to);\n\n        const oldEdges = await this.state.edges.slice();\n        await oldEdges.push({\n            from: from,\n            to: to,\n            color: \"black\",\n            width: 3,\n            k_out: k_out\n        });\n\n        const oldFollowerList = await this.state.followerList;\n        await oldFollowerList[from].push(to);\n        await this.setState({\n            followerList: oldFollowerList,\n            edges: oldEdges,\n        });\n    }\n\n    DisplayAddingStatus() {\n        if (this.state.addingEdge && this.state.from === 0) {\n            return (\n                <p>Select starting vertex</p>\n            );\n        } else if (this.state.addingEdge && this.state.from !== 0) {\n            return (\n                <p>Select ending vertex</p>\n            );\n        } else {\n            return (<p>doing nothing</p>);\n        }\n    }\n\n    /**\n     * Action performed after node is selected via mouse click\n     *\n     * @param event - Event provided by mouse click\n     * @returns {Promise<void>}\n     */\n    async selectVertex(event) {\n        const {nodes} = event;\n\n        if (this.state.addingEdge && this.state.from !== 0) {\n            await this.setState({\n                to: nodes[0],\n                addingEdge: false\n            });\n            //await this.addEdge();\n        }\n        await this.setState({\n            from: nodes[0]\n        })\n\n    }\n\n    /**\n     * Stops program for specified amount of time\n     *\n     * @param sleepTime - Time to sleep\n     * @returns {Promise<unknown>}\n     */\n    sleepNow = (sleepTime) => new Promise((r) => setTimeout(r, sleepTime));\n\n    /**\n     * Changing parameters of vertex with given id to specified attributes\n     *\n     * @param id - ID of the node to be changed\n     * @param color - Color to be set\n     * @param levelIncrease - Value by which nodes level should be increased\n     * @param degreeIncrease - Value by which nodes degree should be increased\n     * @returns {Promise<void>}\n     */\n    async changeVertex(id, color, levelIncrease, degreeIncrease = 0) {\n        await this.setState(prevState => {\n            prevState.nodes = prevState.nodes.map(node => {\n                if (node.id === id) {\n                    return {\n                        id: id,\n                        level: node.level + levelIncrease,\n                        inDegree: node.inDegree + degreeIncrease,\n                        label: id.toString() + \", \" + (node.level + levelIncrease).toString(),\n                        title: node.title,\n                        color: color\n                    }\n                }\n                return node;\n            })\n            return {\n                nodes: prevState.nodes\n            };\n        })\n    }\n\n    /**\n     * Changes inProgress flag\n     */\n    changeProgress() {\n        this.setState(prevState => {\n            return {\n                inProgress: !prevState.inProgress\n            };\n        })\n    }\n\n    /**\n     * Adds vertex to set of visited vertices\n     *\n     * @param vertex - ID of vertex to be added\n     * @returns {Promise<void>}\n     */\n    async addVisitedVertex(vertex) {\n        await this.setState(prevState => {\n            prevState.visited.push(vertex);\n            return prevState;\n        })\n    }\n\n    /**\n     * Clears set of visited vertices\n     *\n     * @returns {Promise<void>}\n     */\n    async clearVisitedVertices() {\n        await this.setState({\n            visited: []\n        })\n    }\n\n    /**\n     * Colors given edge to red color (used for animation of searching through edges)\n     *\n     * @param from - Starting vertex of edge\n     * @param to - Ending vertex of edge\n     * @param color - Color of the edge\n     * @param newKOut - new value of k_out for current edge\n     * @returns {Promise<void>}\n     */\n    async changeEdge(from, to, color, newKOut = 0) {\n        let oldEdges = await this.state.edges.slice();\n        const index = oldEdges.findIndex(item =>\n            item.from === from && item.to === to\n        );\n        const edgeKOut = oldEdges[index].k_out;\n        await oldEdges.splice(index, 1);\n        await oldEdges.push({\n                from: from,\n                to: to,\n                k_out: (newKOut === 0) ? edgeKOut : newKOut,\n                color: color,\n                width: 3\n            }\n        )\n        await this.setState({\n            edges: oldEdges,\n        });\n    }\n\n\n    /**\n     * Colors whole graph back to default colors\n     *\n     * @returns {Promise<void>}\n     */\n    async colorGraphToDefault() {\n        /**\n         * Coloring all edges back to black\n         */\n        let oldEdges = await this.state.edges.slice();\n        for (let i = 0; i < oldEdges.length; ++i) {\n            let tmpEdge = {\n                from: oldEdges[0].from,\n                to: oldEdges[0].to,\n                k_out: oldEdges[0].k_out,\n                color: \"black\",\n                width: 3\n            };\n\n            await oldEdges.splice(0, 1);\n            await oldEdges.push(tmpEdge);\n        }\n\n        await this.setState({\n            edges: oldEdges,\n        });\n\n        /**\n         * Coloring all vertices to default\n         */\n        await this.setState(prevState => {\n            prevState.nodes = prevState.nodes.map(node => {\n                node = {\n                    id: node.id,\n                    level: node.level,\n                    inDegree: node.inDegree,\n                    label: node.label,\n                    title: node.title,\n                    color: this.color[node.level - 1]\n                }\n                return node;\n            })\n            return {\n                nodes: prevState.nodes\n            };\n        })\n    }\n\n    /**\n     * Sets value of pause using value in number input\n     */\n    setTimeoutFromInput() {\n        this.setState({\n            timeout: this.state.timeoutInput\n        })\n    }\n\n\n    /**************************/\n\n    /* Sparse graph algorithm */\n\n    /**\n     * Main procedure of algorithm for sparse graphs\n     *\n     * @returns {Promise<boolean>}\n     */\n    async insertEdgeSparse() {\n        let forward = false;\n        let actualStatus;\n\n        let fromVertex = this.state.nodes[this.state.nodes.findIndex(node => node.id === this.state.from)],\n            toVertex = this.state.nodes[this.state.nodes.findIndex(node => node.id === this.state.to)];\n\n        await this.changeVertex(fromVertex.id, \"orange\", 0);\n        await this.changeVertex(toVertex.id, \"orange\", 0);\n\n        await this.changeValue(\"mainProcedureStep\", 1);\n        await this.sleepNow(this.state.timeout);\n\n        // await console.log(\"fromVertex:\", fromVertex, \"toVertex:\", toVertex);\n        // await console.log(\"delta:\", this.state.delta);\n\n\n        if (!(await this.testOrdering(this.state.from, this.state.to))) {\n\n            /**\n             * Opravit v implementaci a BP!!!\n             */\n            actualStatus = await this.backwardSearch(fromVertex.id, toVertex.id);\n\n            if (actualStatus === this.status.CYCLE_FOUND) {\n                await this.changeValue(\"mainProcedureStep\", 4);\n                await this.sleepNow(this.state.timeout);\n                await this.changeValue(\"mainProcedureStep\", 5);\n                await this.sleepNow(this.state.timeout);\n                await this.changeValue(\"mainProcedureStep\", 0);\n\n                return true;\n            } else if (actualStatus === this.status.LESS_THAN_DELTA_EDGES && (toVertex.level < fromVertex.level)) {\n\n                await this.changeValue(\"mainProcedureStep\", 6);\n                await this.sleepNow(this.state.timeout);\n                await this.changeValue(\"mainProcedureStep\", 7);\n                await this.sleepNow(this.state.timeout);\n\n                await this.changeVertex(toVertex.id, \"orange\", (fromVertex.level - toVertex.level));\n                await this.setEinOfVertex(toVertex.id, []);\n                forward = true;\n            } else if (actualStatus === this.status.MORE_THAN_DELTA_EDGES) {\n\n                await this.changeValue(\"mainProcedureStep\", 8);\n                await this.sleepNow(this.state.timeout);\n                await this.changeValue(\"mainProcedureStep\", 9);\n                await this.sleepNow(this.state.timeout);\n\n                await this.changeVertex(toVertex.id, \"orange\", ((fromVertex.level - toVertex.level) + 1));\n                await this.setEinOfVertex(toVertex.id, []);\n                await this.clearVisitedVertices();\n                await this.addVisitedVertex(fromVertex.id);\n                forward = true;\n            }\n\n            if (forward) {\n                await this.changeValue(\"mainProcedureStep\", 10);\n                await this.setSubprocedureStep(3, 0);\n                await this.sleepNow(this.state.timeout);\n\n                actualStatus = (await this.forwardSearch(this.state.to));\n                if (actualStatus) {\n                    await this.changeValue(\"mainProcedureStep\", 11);\n                    await this.sleepNow(this.state.timeout);\n                    await this.changeValue(\"mainProcedureStep\", 0);\n\n                    return true;\n                }\n            }\n        }\n\n        await this.colorGraphToDefault();\n\n        await this.changeValue(\"mainProcedureStep\", 12);\n        await this.sleepNow(this.state.timeout);\n\n        await this.addingEdge(fromVertex.id, toVertex.id);\n        await this.clearVisitedVertices();\n        await this.changeValue(\"mainProcedureStep\", 0);\n        await this.setSubprocedureStep(0, 0);\n        return false;\n    }\n\n    async testOrdering(from, to) {\n        let fromLevel = this.state.nodes[this.state.nodes.findIndex(node => node.id === from)].level,\n            toLevel = this.state.nodes[this.state.nodes.findIndex(node => node.id === to)].level;\n\n        await this.changeValue(\"mainProcedureStep\", 2);\n        await this.setSubprocedureStep(1, 0);\n        await this.sleepNow(this.state.timeout);\n        await this.setSubprocedureStep(1, 1);\n        await this.sleepNow(this.state.timeout);\n        await this.setSubprocedureStep(0, 0);\n        return (fromLevel < toLevel);\n    }\n\n    async backwardSearch(start, w) {\n        await this.changeValue(\"mainProcedureStep\", 3);\n        await this.setSubprocedureStep(2, 0);\n        await this.sleepNow(this.state.timeout);\n        await this.setSubprocedureStep(2, 1);\n        await this.sleepNow(this.state.timeout);\n\n        if (start === w) {\n            await this.setSubprocedureStep(2, 2);\n            await this.sleepNow(this.state.timeout);\n\n            return this.status.CYCLE_FOUND;\n        }\n        await this.setSubprocedureStep(2, 3);\n        await this.sleepNow(this.state.timeout);\n\n        await this.addVisitedVertex(start);\n\n        await this.setSubprocedureStep(2, 4);\n        await this.sleepNow(this.state.timeout);\n        if (this.state.e_in[start].length === 0 && this.state.visited.length >= this.state.delta + 1) {\n            await this.setSubprocedureStep(2, 5);\n            await this.sleepNow(this.state.timeout);\n\n            return this.status.MORE_THAN_DELTA_EDGES;\n        }\n\n        for (let i = 0; i < this.state.e_in[start].length; ++i) {\n            let predecessor = await this.state.e_in[start][i];\n\n            await this.setSubprocedureStep(2, 8);\n            await this.sleepNow(this.state.timeout);\n\n            if (this.state.visited.length >= this.state.delta + 1) {\n\n                await this.setSubprocedureStep(2, 9);\n                await this.sleepNow(this.state.timeout);\n                await this.setSubprocedureStep(0, 0);\n\n                return this.status.MORE_THAN_DELTA_EDGES;\n            }\n\n            if (this.state.visited.includes(predecessor)) {\n                continue;\n            }\n\n            // Coloring backward-searched edges\n            await this.changeEdge(predecessor, start, \"red\");\n            await this.setSubprocedureStep(2, 10);\n            await this.sleepNow(this.state.timeout);\n            let actualStatus = await this.backwardSearch(predecessor, w);\n\n            await this.setSubprocedureStep(2, 11);\n            await this.sleepNow(this.state.timeout);\n            if (actualStatus === this.status.CYCLE_FOUND || actualStatus === this.status.MORE_THAN_DELTA_EDGES) {\n                if (actualStatus === this.status.CYCLE_FOUND) {\n                    await this.setSubprocedureStep(2, 12);\n                    await this.sleepNow(this.state.timeout);\n                } else if (actualStatus === this.status.MORE_THAN_DELTA_EDGES) {\n                    await this.setSubprocedureStep(2, 13);\n                    await this.sleepNow(this.state.timeout);\n                }\n                await this.setSubprocedureStep(0, 0);\n                return actualStatus;\n            }\n            await this.setSubprocedureStep(2, 14);\n            await this.sleepNow(this.state.timeout);\n        }\n        await this.setSubprocedureStep(2, 15);\n        await this.sleepNow(this.state.timeout);\n        await this.setSubprocedureStep(0, 0);\n        return this.status.LESS_THAN_DELTA_EDGES;\n    }\n\n    async forwardSearch(w) {\n        // Simulation of set (JS set is not very smart)\n        await this.setSubprocedureStep(3, 1);\n        await this.sleepNow(this.state.timeout);\n\n        let F = [w];\n\n        while (F.length) {\n            await this.setSubprocedureStep(3, 2);\n            await this.sleepNow(this.state.timeout);\n\n            let actual = await F.pop();\n            actual = this.state.nodes[this.state.nodes.findIndex(node => node.id === actual)];\n\n            for (let i = 0; i < this.state.followerList[actual.id].length; ++i) {\n\n                let successor = await this.state.followerList[actual.id][i];\n                successor = this.state.nodes[this.state.nodes.findIndex(node => node.id === successor)];\n\n                // Animation\n                //console.log(\"Searching forward edge: (\", actual.id, \", \", successor.id, \")\");\n                await this.changeEdge(actual.id, successor.id, \"blue\");\n                await this.setSubprocedureStep(3, 3);\n                await this.sleepNow(this.state.timeout);\n\n                if (this.state.visited.includes(successor.id)) {\n                    await this.setSubprocedureStep(3, 4);\n                    await this.sleepNow(this.state.timeout);\n                    await this.setSubprocedureStep(0, 0);\n\n                    return true;\n                }\n\n                if (actual.level === successor.level) {\n                    await this.setSubprocedureStep(3, 5);\n                    await this.sleepNow(this.state.timeout);\n                    await this.setSubprocedureStep(3, 6);\n                    await this.sleepNow(this.state.timeout);\n\n                    await this.addVertexToEin(successor.id, actual.id);\n                } else if (actual.level > successor.level) {\n                    await this.setSubprocedureStep(3, 7);\n                    await this.sleepNow(this.state.timeout);\n                    await this.setSubprocedureStep(3, 8);\n                    await this.sleepNow(this.state.timeout);\n\n                    await this.changeVertex(successor.id, this.color[successor.level + (actual.level - successor.level) - 1], (actual.level - successor.level));\n                    await this.setEinOfVertex(successor.id, [actual.id]);\n                    await F.push(successor.id);\n                }\n            }\n        }\n        await this.setSubprocedureStep(3, 9);\n        await this.sleepNow(this.state.timeout);\n        await this.setSubprocedureStep(0, 0);\n\n        return false;\n    }\n\n    async addingEdge(from, to) {\n\n        from = this.state.nodes[this.state.nodes.findIndex(node => node.id === from)];\n        to = this.state.nodes[this.state.nodes.findIndex(node => node.id === to)];\n\n        await this.setSubprocedureStep(4, 1);\n        await this.sleepNow(this.state.timeout);\n\n        await this.addEdge();\n\n        if (from.level === to.level) {\n            await this.setSubprocedureStep(4, 2);\n            await this.sleepNow(this.state.timeout);\n            await this.setSubprocedureStep(4, 3);\n            await this.sleepNow(this.state.timeout);\n\n            await this.addVertexToEin(to.id, from.id);\n        }\n        await this.setSubprocedureStep(4, 4);\n        await this.sleepNow(this.state.timeout);\n\n        await this.changeValue(\"delta\", await Math.min(await Math.sqrt(this.state.edges.length),\n            await Math.pow(this.state.nodes.length, (2 / 3))));\n\n        await this.setSubprocedureStep(0, 0);\n    }\n\n    /**************************/\n\n    async insertEdgeDense() {\n        //await console.log(this.state);\n\n        let fromVertex = this.state.nodes[this.state.nodes.findIndex(node => node.id === this.state.from)],\n            toVertex = this.state.nodes[this.state.nodes.findIndex(node => node.id === this.state.to)];\n\n        // Coloring edges + increasing in-degree of ending edge\n        await this.changeVertex(fromVertex.id, \"orange\", 0);\n        await this.changeVertex(toVertex.id, \"orange\", 0, 1);\n        toVertex.inDegree++;\n\n        await this.changeValue(\"mainProcedureStep\", 1);\n        await this.sleepNow(this.state.timeout);\n\n\n        if (fromVertex.level < toVertex.level) {\n\n            await this.changeValue(\"mainProcedureStep\", 2);\n            await this.sleepNow(this.state.timeout);\n            await this.changeValue(\"mainProcedureStep\", 3);\n            await this.sleepNow(this.state.timeout);\n\n            let j = Math.floor(Math.log2(Math.min(toVertex.level - fromVertex.level, toVertex.inDegree)));\n\n            //await console.log(`j = ${j}`);\n\n            if (toVertex.inDegree === Math.pow(2, j)) {\n\n                await this.changeValue(\"mainProcedureStep\", 4);\n                await this.sleepNow(this.state.timeout);\n\n                let oldB = await this.state.b.slice();\n                oldB[j][toVertex.id] = await toVertex.level;\n                await this.setState({\n                    b: oldB\n                })\n\n                let oldC = await this.state.c.slice();\n                oldC[j][toVertex.id] = 0;\n                oldC[j - 1][toVertex.id] = 0;\n                await this.setState({\n                    c: oldC\n                })\n                await this.changeValue(\"mainProcedureStep\", 5);\n                await this.sleepNow(this.state.timeout);\n            }\n\n            await this.changeValue(\"mainProcedureStep\", 6);\n            await this.sleepNow(this.state.timeout);\n            await this.changeValue(\"mainProcedureStep\", 7);\n            await this.sleepNow(this.state.timeout);\n\n            await this.addEdge(toVertex.level);\n\n            await this.changeValue(\"mainProcedureStep\", 8);\n            await this.sleepNow(this.state.timeout);\n\n            return false;\n        }\n\n        await this.addEdge(toVertex.level);\n        await this.changeEdge(fromVertex.id, toVertex.id, \"white\");\n\n        await this.changeValue(\"mainProcedureStep\", 9);\n        await this.sleepNow(this.state.timeout);\n\n        let T = [{from: fromVertex.id, to: toVertex.id}];\n\n        while (T.length) {\n\n            await this.changeValue(\"mainProcedureStep\", 10);\n            await this.sleepNow(this.state.timeout);\n\n            let currentEdge = await T.pop();\n\n            //await console.log(currentEdge);\n\n            await this.changeValue(\"mainProcedureStep\", 11);\n            await this.sleepNow(this.state.timeout);\n            if (await this.traversalStep(currentEdge.from, currentEdge.to, T, fromVertex.id)) {\n\n                await this.changeValue(\"mainProcedureStep\", 12);\n                await this.sleepNow(this.state.timeout);\n                await this.changeValue(\"mainProcedureStep\", 0);\n\n                return true;\n            }\n\n            //await console.log(`traversed edge: from: ${currentEdge.from} to: ${currentEdge.to}`)\n            //await console.log(this.state.edges)\n        }\n        await this.colorGraphToDefault();\n\n        await this.changeValue(\"mainProcedureStep\", 13);\n        await this.sleepNow(this.state.timeout);\n\n        await this.clearVisitedVertices();\n        await this.changeValue(\"mainProcedureStep\", 0);\n        await this.setSubprocedureStep(0, 0);\n\n        return false;\n    }\n\n    async traversalStep(from, to, T, v) {\n\n        await this.changeEdge(from, to, \"blue\");\n        await this.setSubprocedureStep(1, 0);\n        await this.sleepNow(this.state.timeout);\n\n        if (to === v) {\n            await this.setSubprocedureStep(1, 1);\n            await this.sleepNow(this.state.timeout);\n            await this.setSubprocedureStep(1, 2);\n            await this.sleepNow(this.state.timeout);\n            await this.setSubprocedureStep(0, 0);\n            await this.sleepNow(this.state.timeout);\n            return true;\n        }\n\n        let fromVertex = this.state.nodes[this.state.nodes.findIndex(node => node.id === from)],\n            toVertex = this.state.nodes[this.state.nodes.findIndex(node => node.id === to)];\n\n        //await console.log(`Entered edge: (${fromVertex.id}, ${toVertex.id}`);\n\n        if (fromVertex.level >= toVertex.level) {\n            await this.setSubprocedureStep(1, 3);\n            await this.sleepNow(this.state.timeout);\n\n            //await console.log(`k(v) = ${fromVertex.level}, k(w) = ${toVertex.level}`)\n            //await console.log(`Changing vertex`)\n            await this.changeVertex(toVertex.id, toVertex.color, (fromVertex.level - toVertex.level) + 1);\n\n            //await console.log(`vertex changed!`)\n            await this.setSubprocedureStep(1, 4);\n            await this.sleepNow(this.state.timeout);\n\n            toVertex = this.state.nodes[this.state.nodes.findIndex(node => node.id === toVertex.id)];\n        } else {\n            await this.setSubprocedureStep(1, 5);\n            await this.sleepNow(this.state.timeout);\n            await this.setSubprocedureStep(1, 6);\n            await this.sleepNow(this.state.timeout);\n\n            let j = Math.floor(Math.log2(Math.min(toVertex.level - fromVertex.level, toVertex.inDegree)));\n\n            let oldC = await this.state.c.slice();\n            oldC[j][toVertex.id] += 1;\n            await this.setState({\n                c: oldC\n            })\n\n            if (this.state.c[j][toVertex.id] === 3 * Math.pow(2, j)) {\n                await this.setSubprocedureStep(1, 7);\n                await this.sleepNow(this.state.timeout);\n                await this.setSubprocedureStep(1, 8);\n                await this.sleepNow(this.state.timeout);\n\n                let oldC = await this.state.c.slice();\n                oldC[j][toVertex.id] = 0;\n                await this.setState({\n                    c: oldC\n                })\n\n                await this.changeVertex(toVertex.id, toVertex.color, Math.max(toVertex.level, this.state.b[j][toVertex.id] + Math.pow(2, j)));\n\n                toVertex = this.state.nodes[this.state.nodes.findIndex(node => node.id === toVertex.id)];\n\n                let oldB = await this.state.b.slice();\n                oldB[j][toVertex.id] = toVertex.level;\n                await this.setState({\n                    b: oldB\n                })\n            }\n        }\n\n        let edgesToBeTraversed = this.state.edges.filter((edge) => {\n            return edge.from === toVertex.id && edge.k_out <= toVertex.level\n        });\n\n        //await console.log(\"Edges to be traversed: \" + edgesToBeTraversed);\n\n        for (let i = 0; i < edgesToBeTraversed.length; ++i) {\n            await this.setSubprocedureStep(1, 9);\n            await this.sleepNow(this.state.timeout);\n            await this.setSubprocedureStep(1, 10);\n            await this.sleepNow(this.state.timeout);\n\n            T.push({from: edgesToBeTraversed[i].from, to: edgesToBeTraversed[i].to});\n        }\n\n        //await console.log(`Actual edge: (${fromVertex.id}, ${toVertex.id}`);\n        //await console.log(this.state.edges);\n\n        await this.setSubprocedureStep(1, 11);\n        await this.sleepNow(this.state.timeout);\n\n        const index = this.state.edges.findIndex(e => e.from === fromVertex.id && e.to === toVertex.id);\n\n        //await console.log(index);\n\n        const edgeColor = this.state.edges[index].color;\n\n        await this.changeEdge(fromVertex.id, toVertex.id, edgeColor, toVertex.level);\n\n        await this.setSubprocedureStep(1, 12);\n        await this.sleepNow(this.state.timeout);\n        await this.setSubprocedureStep(0, 0);\n\n        return false;\n    }\n\n    async mainProcedure() {\n        if (!this.state.inProgress) {\n            const from = parseInt(this.state.from);\n            const to = parseInt(this.state.to);\n\n            await this.changeProgress();\n\n            if (to === from) {\n                window.alert(\"Smyčky jsou zakázány!\");\n            } else if (this.state.edges.some(edge => edge.from === from && edge.to === to)) {\n                window.alert(\"Hrana již existuje!\");\n            } else if (from > this.state.numberOfVertices || to > this.state.numberOfVertices ||\n                from < 1 || to < 1) {\n                await window.alert(\"Zvolené vrcholy se v grafu nenacházejí!\");\n            } else if (this.state.graphType === \"sparse\") {\n                if (await this.insertEdgeSparse()) {\n                    // Adding edge which creates cycle (green color)\n                    await this.addEdge();\n                    await this.changeEdge(this.state.from, this.state.to, \"green\");\n\n                    await console.log(\"cycle\");\n                    await window.alert(\"Zjištěn cyklus!\");\n                }\n            } else if (this.state.graphType === \"dense\") {\n                if (await this.insertEdgeDense()) {\n                    await this.addEdge();\n                    await this.changeEdge(this.state.from, this.state.to, \"green\");\n\n                    await console.log(\"cycle\");\n                    await window.alert(\"Zjištěn cyklus!\");\n                }\n            }\n            await this.changeProgress();\n        }\n    }\n\n\n    async step() {\n        await this.changeValue(\"from\", this.state.sequenceToAdd[0][0]);\n        await this.changeValue(\"to\", this.state.sequenceToAdd[0][1]);\n        /**\n         * This is actual algorithm\n         */\n        await this.mainProcedure();\n\n        let tmp = this.state.sequenceToAdd.slice();\n        tmp.shift();\n        await this.changeValue(\"sequenceToAdd\", tmp);\n    }\n\n    SparseGraphDemoStep() {\n        function renderTupleList(list) {\n            let out = \"\";\n            for (let i = 0; i < list.length; ++i) {\n                out += \"(\" + list[i][0] + \", \" + list[i][1] + \")\";\n                out += (i < list.length - 1) ? \", \" : \"\";\n            }\n            return out;\n        }\n\n        return (\n            <div\n                className={\"graphLayout\"}\n                style={{\n                    marginLeft: 10\n                }}\n            >\n                <div>\n                    <p>Sekvence hran k vložení: {renderTupleList(this.state.sequenceToAdd)}</p>\n                    <p>Přidávám hranu z {this.state.from} do {this.state.to}</p>\n                    <br/>\n                    <button\n                        onClick={this.step}\n                    >\n                        Přidat hranu ze sekvence\n                    </button>\n                    <br/><br/>\n                    <label>\n                        <input\n                            name={\"timeoutInput\"}\n                            type={\"number\"}\n                            value={this.state.timeoutInput}\n                            onChange={this.handleChange}\n                        />\n                        Délka kroku\n                    </label>\n                    <button\n                        onClick={this.setTimeoutFromInput}\n                    >\n                        Nastav délku kroku\n                    </button>\n                </div>\n                <div>\n                    {(this.state.graphType === \"sparse\")? <h2 style={{margin: 40}}>&#916; = {this.state.delta}</h2> : \"\"}\n                </div>\n            </div>\n        )\n    }\n\n    async cancelDemo() {\n        await this.changeValue(\"sequenceToAdd\", []);\n        await this.changeValue(\"numberOfVertices\", 0);\n        await this.setSubprocedureStep(0, 0);\n        await this.generateGraph();\n        //await console.log(this.state.sequenceToAdd);\n    }\n\n    cancelDemoButton() {\n        return (\n            <button\n                onClick={(!this.state.inProgress) ? this.cancelDemo : () => {\n                }}\n            >\n                Zruš demo\n            </button>\n        )\n    }\n\n    manualAdding() {\n        return (\n            <div\n                className={\"graphLayout\"}\n                style={{\n                    marginLeft: 10\n                }}\n            >\n                <div>\n                    <p>Přidávám hranu z {this.state.from} do {this.state.to}</p>\n                    <br/>\n\n                    <div>\n                        <label>\n                            <input\n                                name={\"from\"}\n                                type={\"number\"}\n                                value={this.state.from}\n                                onChange={(!this.state.inProgress) ? this.handleChange : () => {\n                                }}\n                            />\n                            Výchozí vrchol\n                        </label>\n\n                        <label>\n                            <input\n                                name={\"to\"}\n                                type={\"number\"}\n                                value={this.state.to}\n                                onChange={(!this.state.inProgress) ? this.handleChange : () => {\n                                }}\n                            />\n                            Cílový vrchol\n                        </label>\n\n                        <button\n                            onClick={() => {\n                                this.mainProcedure();\n                            }}\n                        >\n                            Vlož hranu\n                        </button>\n                    </div>\n                    <br/>\n                    <label>\n                        <input\n                            name={\"timeoutInput\"}\n                            type={\"number\"}\n                            value={this.state.timeoutInput}\n                            onChange={this.handleChange}\n                        />\n                        Délka kroku\n                    </label>\n                    <button\n                        onClick={this.setTimeoutFromInput}\n                    >\n                        Nastav délku kroku\n                    </button>\n                </div>\n                <div>\n                    {(this.state.graphType === \"sparse\")? <h2 style={{margin: 40}}>&#916; = {this.state.delta}</h2> : \"\"}\n                </div>\n            </div>\n        )\n    }\n\n    render() {\n        const graph = {nodes: this.state.nodes, edges: this.state.edges};\n\n        const options = {\n            layout: {\n                //hierarchical: true\n            },\n            edges: {\n                color: \"#000000\",\n                smooth: {type: \"curvedCCW\"}\n            },\n            physics: {\n                enabled: false\n            },\n            height: \"500px\",\n        };\n\n        const events = {\n            // arrow function can access scope of whole component class\n            selectNode: async (event) => {\n                //await this.selectVertex(event)\n            },\n\n            dragStart: async (event) => {\n                //await this.selectVertex(event)\n            }\n        };\n        return (\n            <div>\n                <div\n                    className={\"topPanel\"}\n                >\n                    <div\n                        className={\"graphBox\"}\n                    >\n                        <text style={{\n                            fontWeight: \"bold\"\n                        }}>Počet vrcholů:\n                        </text>\n                        <input\n                            name={\"numberOfVertices\"}\n                            type={\"number\"}\n                            value={this.state.numberOfVertices}\n                            onChange={this.handleChange}\n                        />\n                        <button\n                            onClick={(!this.state.inProgress) ? this.generateGraph : () => {\n                            }}\n                        >\n                            Generuj graf\n                        </button>\n                    </div>\n                    <div\n                        className={\"pseudoCode\"}\n                    >\n                        <SparseGraphDemoLoading\n                            state={this.state}\n                            changeValue={this.changeValue}\n                            generateGraph={this.generateGraph}\n                        />\n                        {(this.state.sequenceToAdd.length !== 0 && !this.state.inProgress) ? this.cancelDemoButton() : () => {\n                        }}\n                    </div>\n                    <div>\n                        <label>\n                            Vyberte algoritmus:\n                            <select value={this.state.graphType} onChange={this.handleDropdownChange}>\n                                <option value={\"sparse\"}>Algoritmus pro řídký graf</option>\n                                <option value={\"dense\"}>Algoritmus pro hustý graf</option>\n                            </select>\n                        </label>\n                    </div>\n                </div>\n                <hr/>\n                <div\n                    className={\"graphLayout\"}\n                >\n                    <div\n                        className={\"graphBox\"}\n                    >\n                        <Graph\n                            graph={graph}\n                            options={options}\n                            events={events}\n                        />\n                    </div>\n\n                    <div\n                        className={\"pseudoCode\"}\n                    >\n                        {(this.state.graphType === \"sparse\") ?\n                            <SparseGraphPseudocode step={this.state.mainProcedureStep}/> :\n                            <DenseGraphPseudocode step={this.state.mainProcedureStep}/>}\n                    </div>\n\n                    <div\n                        className={\"procedure\"}\n                    >\n                        {(this.state.graphType === \"sparse\") ? <SparseGraphSubprocedure\n                            procedure={this.state.subprocedure}\n                            step={this.state.subprocedureStep}\n                        /> : <DenseGraphSubprocedure\n                            procedure={this.state.subprocedure}\n                            step={this.state.subprocedureStep}\n                        />}\n                    </div>\n                </div>\n                <hr/>\n                {(this.state.sequenceToAdd.length !== 0) ?\n                    this.SparseGraphDemoStep()\n                    : this.manualAdding()}\n            </div>\n\n        )\n    }\n}\n\nexport default NetworkGraph;\n\n\n/*\n                <DFS\n                    state={this.state}\n                    changeProgress={this.changeProgress}\n                    colorGraphToDefault={this.colorGraphToDefault}\n                    sleepNow={this.sleepNow}\n                    visited={this.visited}\n                    colorEdgeToRed={this.colorEdgeToRed}\n                    changeVertex={this.changeVertex}\n                    addVisitedVertices={this.addVisitedVertex}\n                    clearVisitedVertices={this.clearVisitedVertices}\n                />\n\n                <button\n                    name={\"addingEdge\"}\n                    onClick={(!this.state.inProgress) ? this.handleChange : () => {\n                    }}\n                >\n                    Add edge with mouse\n                </button>\n\n                {this.DisplayAddingStatus()}\n\n                <button\n                    name={\"addingEdge\"}\n                    onClick={(!this.state.inProgress) ? this.handleChange : () => {\n                    }}\n                >\n                    Add edge with mouse\n                </button>\n\n                 <button\n                    onClick={(!this.state.inProgress) ? this.addEdge : () => {\n                    }}\n                >\n                    Add edge\n                </button>\n\n\n\n                <SparseGraph\n                    state={this.state}\n                    sleepNow={this.sleepNow}\n                    handleChange={this.handleChange}\n                    colorGraphToDefault={this.colorGraphToDefault}\n                    colorEdgeToRed={this.colorEdgeToRed}\n                    changeProgress={this.changeProgress}\n                    changeVertex={this.changeVertex}\n                    addVisitedVertex={this.addVisitedVertex}\n                    clearVisitedVertices={this.clearVisitedVertices}\n                    addVertexToEin={this.addVertexToEin}\n                    setEinOfVertex={this.setEinOfVertex}\n                    addEdge={this.addEdge}\n                    incrementM={this.incrementM}\n                    setDelta={this.setDelta}\n                />\n */","/home/rumec/Documents/BP/BP/visualization/src/components/SparseGraphPseudocode.js",["51","52","53","54","55","56","57","58","59","60","61","62","63","64"],"import React from \"react\";\n\nfunction SparseGraphPseudocode(props) {\n    return (\n        <div>\n                <h3>Hlavni procedura:</h3>\n\n            <div style={{fontWeight: \"bold\"}}>function VlozeniHrany(Graf, hrana)</div>\n            <div style={{textIndent: 15, backgroundColor: (props.step === 1)?\"yellow\" : \"white\"}}>v, w &#8592; hrana</div>\n            <div style={{textIndent: 15, backgroundColor: (props.step === 1)?\"yellow\" : \"white\"}}>B &#8592; &#8709;</div>\n            <div style={{textIndent: 15, backgroundColor: (props.step === 1)?\"yellow\" : \"white\"}}>dopredny &#8592; False</div>\n            <div style={{textIndent: 15, backgroundColor: (props.step === 2)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>if</a> &#172;TestUsporadani(Graf, v, w) <a style={{fontWeight: \"bold\"}}>then</a></div>\n            <div style={{textIndent: 45, backgroundColor: (props.step === 3)?\"yellow\" : \"white\"}}>s &#8592; ZpetnyPruzkum(Graf, v, w, b)</div>\n            <div style={{textIndent: 30}}><a style={{fontWeight: \"bold\"}}>end if </a></div>\n            <div style={{textIndent: 30, backgroundColor: (props.step === 4)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>if</a>{\" s = CyklusNalezen \"}<a style={{fontWeight: \"bold\"}}>then</a></div>\n            <div style={{textIndent: 45, backgroundColor: (props.step === 5)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>return</a>{\" True\"}</div>\n            <div style={{textIndent: 30, backgroundColor: (props.step === 6)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>else if</a> s = Neprekroceno &#8743; {\"Graf.k(v) < Graf.k(w) \"}<a style={{fontWeight: \"bold\"}}>then</a></div>\n            <div style={{textIndent: 45, backgroundColor: (props.step === 7)?\"yellow\" : \"white\"}}>Graf.k(w) &#8592; Graf.k(v)</div>\n            <div style={{textIndent: 45, backgroundColor: (props.step === 7)?\"yellow\" : \"white\"}}>Graf.in(w) &#8592; {}</div>\n            <div style={{textIndent: 45, backgroundColor: (props.step === 7)?\"yellow\" : \"white\"}}>dopredny &#8592; True</div>\n            <div style={{textIndent: 30, backgroundColor: (props.step === 8)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>else if</a>{\" s = Prekroceno \"}<a style={{fontWeight: \"bold\"}}>then</a></div>\n            <div style={{textIndent: 45, backgroundColor: (props.step === 9)?\"yellow\" : \"white\"}}>Graf.k(w) &#8592; Graf.k(v) + 1</div>\n            <div style={{textIndent: 45, backgroundColor: (props.step === 9)?\"yellow\" : \"white\"}}>Graf.in(w) &#8592; &#8709;</div>\n            <div style={{textIndent: 45, backgroundColor: (props.step === 9)?\"yellow\" : \"white\"}}>B &#8592; {\"{v}\"}</div>\n            <div style={{textIndent: 45, backgroundColor: (props.step === 9)?\"yellow\" : \"white\"}}>dopredny &#8592; True</div>\n            <div style={{textIndent: 30, fontWeight: \"bold\"}}>{\"end if\"}</div>\n            <div style={{textIndent: 30, backgroundColor: (props.step === 10)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>if</a> dopredny &#8743; DoprednyPruzkum(Graf, w, B) <a style={{fontWeight: \"bold\"}}>then</a></div>\n            <div style={{textIndent: 45, backgroundColor: (props.step === 11)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>return</a>{\" True\"}</div>\n            <div style={{textIndent: 30, fontWeight: \"bold\"}}>{\"end if\"}</div>\n            <div style={{textIndent: 15, fontWeight: \"bold\"}}>{\"end if\"}</div>\n            <div style={{textIndent: 15, backgroundColor: (props.step === 12)?\"yellow\" : \"white\"}}>{\"PridaniHrany(Graf, v, w)\"}</div>\n            <div style={{textIndent: 15, backgroundColor: (props.step === 12)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>return</a>{\" False\"}</div>\n        </div>\n    )\n}\n\nexport default SparseGraphPseudocode;","/home/rumec/Documents/BP/BP/visualization/src/components/SparseGraphDemoLoading.js",[],"/home/rumec/Documents/BP/BP/visualization/src/components/SparseGraphSubprocedure.js",["65","66","67","68","69","70","71","72","73","74","75","76","77","78","79","80","81","82","83","84","85","86","87","88","89","90","91","92","93","94","95","96","97","98","99","100","101","102","103","104","105","106","107","108"],"import React from \"react\";\n\nfunction SparseGraphSubprocedurePseudocode(props) {\n    switch (props.procedure) {\n        case 1: return (\n            <div>\n                <div style={{fontWeight: \"bold\"}}>function TestUsporadani(Graf, v, w)</div>\n                <div style={{textIndent: 15, backgroundColor: (props.step === 1)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>return</a>{\" Graf.k(v) < Graf.k(w)\"}</div>\n            </div>\n        );\n        case 2: return (\n            <div>\n                <div style={{fontWeight: \"bold\"}}>function ZpetnyPruzkum(Graf, start, w, B)</div>\n                <div style={{textIndent: 15, backgroundColor: (props.step === 1)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>if</a>{\" start = w \"}<a style={{fontWeight: \"bold\"}}>then</a></div>\n                <div style={{textIndent: 30, backgroundColor: (props.step === 2)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>return</a>{\" CyklusNaleezen\"}</div>\n                <div style={{textIndent: 15}}><a style={{fontWeight: \"bold\"}}>end if</a></div>\n                <div style={{textIndent: 15, backgroundColor: (props.step === 3)?\"yellow\" : \"white\"}}>B &#8592; B &#8746; {\"{v}\"}</div>\n                <div style={{textIndent: 15, backgroundColor: (props.step === 4)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>if</a> Graf.in(start) = &#8709; &#8743; B.size() &#8805; Graf.delta <a style={{fontWeight: \"bold\"}}>then</a></div>\n                <div style={{textIndent: 30, backgroundColor: (props.step === 5)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>return</a>{\" Prekroceno\"}</div>\n                <div style={{textIndent: 15}}><a style={{fontWeight: \"bold\"}}>end if</a></div>\n                <div style={{textIndent: 15}}><a style={{fontWeight: \"bold\"}}>foreach</a>{\" (predchudce, start)\"} &#8712; {\"Graf.in(start) \"}<a style={{fontWeight: \"bold\"}}>do</a></div>\n                <div style={{textIndent: 30, backgroundColor: (props.step === 8)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>if</a> B.size() &#8805; Graf.delta <a style={{fontWeight: \"bold\"}}>then</a></div>\n                <div style={{textIndent: 45, backgroundColor: (props.step === 9)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>return</a>{\" Prekroceno\"}</div>\n                <div style={{textIndent: 30, fontWeight: \"bold\"}}>{\"end if\"}</div>\n                <div style={{textIndent: 30, backgroundColor: (props.step === 10)?\"yellow\" : \"white\"}}>status &#8592; ZpetnyPruzkum(Graf, predchudce, w, B)</div>\n                <div style={{textIndent: 30, backgroundColor: (props.step === 11)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>switch</a>{\" status \"}<a style={{fontWeight: \"bold\"}}>do</a></div>\n                <div style={{textIndent: 45, backgroundColor: (props.step === 12)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>case: </a>{\"CyklusNalezen: \"}<a style={{fontWeight: \"bold\"}}>return</a> CyklusNalezen</div>\n                <div style={{textIndent: 45, backgroundColor: (props.step === 13)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>case: </a>{\"Prekroceno: \"}<a style={{fontWeight: \"bold\"}}>return</a> Prekroceno</div>\n                <div style={{textIndent: 45, backgroundColor: (props.step === 14)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>default: </a>{}<a style={{fontWeight: \"bold\"}}>continue</a></div>\n                <div style={{textIndent: 30}}><a style={{fontWeight: \"bold\"}}>end switch</a>{}</div>\n                <div style={{textIndent: 15}}><a style={{fontWeight: \"bold\"}}>end for</a>{}</div>\n                <div style={{textIndent: 15, backgroundColor: (props.step === 15)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>return </a>Neprekroceno</div>\n            </div>\n        );\n        case 3: return (\n            <div>\n                <div style={{fontWeight: \"bold\"}}>function DoprednyPruzkum(Graf, w, B)</div>\n                <div style={{textIndent: 15, backgroundColor: (props.step === 1)?\"yellow\" : \"white\"}}>F &#8592; {\"{w}\"}</div>\n                <div style={{textIndent: 15}}><a style={{fontWeight: \"bold\"}}>while</a> F &#8800; &#8709; <a style={{fontWeight: \"bold\"}}>do</a></div>\n                <div style={{textIndent: 30, backgroundColor: (props.step === 2)?\"yellow\" : \"white\"}}>aktualni &#8592; F.pop()</div>\n                <div style={{textIndent: 30}}><a style={{fontWeight: \"bold\"}}>foreach</a>{\" (a, n)\"} &#8712; {\"Graf.out(aktualni) \"}<a style={{fontWeight: \"bold\"}}>do</a></div>\n                <div style={{textIndent: 45, backgroundColor: (props.step === 3)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>if</a> n &#8712; B <a style={{fontWeight: \"bold\"}}>then</a></div>\n                <div style={{textIndent: 60, backgroundColor: (props.step === 4)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>return</a>{\" True\"}</div>\n                <div style={{textIndent: 45}}><a style={{fontWeight: \"bold\"}}>end if</a></div>\n                <div style={{textIndent: 45, backgroundColor: (props.step === 5)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>if</a> Graf.k(a) = Graf.k(n) <a style={{fontWeight: \"bold\"}}>then</a></div>\n                <div style={{textIndent: 60, backgroundColor: (props.step === 6)?\"yellow\" : \"white\"}}>Graf.in(n) &#8592; Graf.in(n) &#8746; {\"{(a, n)}\"}</div>\n                <div style={{textIndent: 45, backgroundColor: (props.step === 7)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>else if</a> Graf.k(a) > Graf.k(n) <a style={{fontWeight: \"bold\"}}>then</a></div>\n                <div style={{textIndent: 60, backgroundColor: (props.step === 8)?\"yellow\" : \"white\"}}>Graf.k(n) &#8592; Graf.k(a)</div>\n                <div style={{textIndent: 60, backgroundColor: (props.step === 8)?\"yellow\" : \"white\"}}>Graf.in(n) &#8592; {\"{(a, n)}\"}</div>\n                <div style={{textIndent: 60, backgroundColor: (props.step === 8)?\"yellow\" : \"white\"}}>F &#8592; F &#8746; {\"{n}\"}</div>\n                <div style={{textIndent: 45}}><a style={{fontWeight: \"bold\"}}>end if</a></div>\n                <div style={{textIndent: 30}}><a style={{fontWeight: \"bold\"}}>end for</a></div>\n                <div style={{textIndent: 15}}><a style={{fontWeight: \"bold\"}}>end while</a></div>\n                <div style={{textIndent: 15, backgroundColor: (props.step === 9)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>return </a>False</div>\n            </div>\n        );\n        case 4: return (\n            <div>\n                <div style={{fontWeight: \"bold\"}}>function PridaniHrany(Graf, v, w)</div>\n                <div style={{textIndent: 15, backgroundColor: (props.step === 1)?\"yellow\" : \"white\"}}>Graf.out(v) &#8592; Graf.out(v) &#8746; {\"{(v, w)}\"}</div>\n                <div style={{textIndent: 15, backgroundColor: (props.step === 2)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>if</a> Graf.k(v) = Graf.k(w) <a style={{fontWeight: \"bold\"}}>then</a></div>\n                <div style={{textIndent: 30, backgroundColor: (props.step === 3)?\"yellow\" : \"white\"}}>Graf.in(w) &#8592; Graf.in(w) &#8746; {\"{(v, w)}\"}</div>\n                <div style={{textIndent: 15}}><a style={{fontWeight: \"bold\"}}>end if</a></div>\n                <div style={{textIndent: 15, backgroundColor: (props.step === 4)?\"yellow\" : \"white\"}}>Graf.m &#8592; Graf.m + 1</div>\n                <div style={{textIndent: 15, backgroundColor: (props.step === 4)?\"yellow\" : \"white\"}}>Graf.delta &#8592; min{\"{\"}m<sup>1/2</sup>, n<sup>2/3</sup>{\"}\"}</div>\n            </div>\n        );\n        default: return(<div> </div>)\n    }\n\n}\n\nfunction SparseGraphSubprocedure(props) {\n    return(\n        <div>\n            <h3>Podprocedura:</h3>\n            <SparseGraphSubprocedurePseudocode\n                procedure={props.procedure}\n                step={props.step}\n            />\n        </div>\n    )\n}\n\nexport default SparseGraphSubprocedure;","/home/rumec/Documents/BP/BP/visualization/src/components/SparseGraphDemoStep.js",[],"/home/rumec/Documents/BP/BP/visualization/src/components/DenseGraphPseudocode.js",["109","110","111","112","113","114","115","116","117","118","119","120","121","122","123"],"import React from \"react\";\n\nfunction DenseGraphPseudocode(props) {\n    return (\n        <div>\n                <h3>Hlavni procedura:</h3>\n\n            <div style={{fontWeight: \"bold\"}}>function VlozeniHrany(v, w)</div>\n            <div style={{textIndent: 15, backgroundColor: (props.step === 1)?\"yellow\" : \"white\"}}>d(w) &#8592; d(w) + 1</div>\n            <div style={{textIndent: 15, backgroundColor: (props.step === 2)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>if</a> {\"k(v) < k(w)\"} <a style={{fontWeight: \"bold\"}}>then</a></div>\n            <div style={{textIndent: 30, backgroundColor: (props.step === 3)?\"yellow\" : \"white\"}}>j &#8592; &#8970;log<sub>2</sub>(min{\"{k(w) - k(v), d(w)}\"})&#8971; </div>\n            <div style={{textIndent: 30, backgroundColor: (props.step === 4)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>if</a> d(w) = 2<sup>j</sup> <a style={{fontWeight: \"bold\"}}>then</a></div>\n            <div style={{textIndent: 45, backgroundColor: (props.step === 5)?\"yellow\" : \"white\"}}>b(j, w) &#8592; k(w)</div>\n            <div style={{textIndent: 45, backgroundColor: (props.step === 5)?\"yellow\" : \"white\"}}>c(j, w) &#8592; 0</div>\n            <div style={{textIndent: 45, backgroundColor: (props.step === 5)?\"yellow\" : \"white\"}}>c(j - 1, w) &#8592; 0</div>\n            <div style={{textIndent: 30}}><a style={{fontWeight: \"bold\"}}>end if </a></div>\n            <div style={{textIndent: 30, backgroundColor: (props.step === 6)?\"yellow\" : \"white\"}}>k<sub>out</sub>(v, w) &#8592; k(w)</div>\n            <div style={{textIndent: 30, backgroundColor: (props.step === 7)?\"yellow\" : \"white\"}}>insert((v, w), out(v))</div>\n            <div style={{textIndent: 30, backgroundColor: (props.step === 8)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>return</a>{\" False\"}</div>\n            <div style={{textIndent: 15}}><a style={{fontWeight: \"bold\"}}>end if </a></div>\n            <div style={{textIndent: 15, backgroundColor: (props.step === 9)?\"yellow\" : \"white\"}}>T &#8592; {\"{(v, w)}\"}</div>\n            <div style={{textIndent: 15, backgroundColor: (props.step === 10)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>while</a> T &#8800; &#8709; <a style={{fontWeight: \"bold\"}}>do</a></div>\n            <div style={{textIndent: 30, backgroundColor: (props.step === 10)?\"yellow\" : \"white\"}}>(x, y) &#8592; pop(T) </div>\n            <div style={{textIndent: 30, backgroundColor: (props.step === 12)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>if</a> PruchodHranou(x, y, T, v) <a style={{fontWeight: \"bold\"}}>then</a></div>\n            <div style={{textIndent: 45, backgroundColor: (props.step === 12)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>return</a>{\" True\"}</div>\n            <div style={{textIndent: 30}}><a style={{fontWeight: \"bold\"}}>end if </a></div>\n            <div style={{textIndent: 15}}><a style={{fontWeight: \"bold\"}}>end while </a></div>\n            <div style={{textIndent: 15, backgroundColor: (props.step === 12)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>return</a>{\" False\"}</div>\n        </div>\n    )\n}\n\nexport default DenseGraphPseudocode;","/home/rumec/Documents/BP/BP/visualization/src/components/DenseGraphSubprocedure.js",["124","125","126","127","128","129","130","131","132","133","134","135","136"],"import React from \"react\";\n\nfunction DenseGraphSubprocedurePseudocode(props) {\n    if (props.procedure !== 0) {\n        return (\n            <div>\n                <div style={{fontWeight: \"bold\"}}>function PruchodHranou(v, w, T, v)</div>\n                <div style={{textIndent: 15, backgroundColor: (props.step === 1)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>if</a> y = v <a style={{fontWeight: \"bold\"}}>then</a></div>\n                <div style={{textIndent: 30, backgroundColor: (props.step === 2)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>return </a>True</div>\n                <div style={{textIndent: 15}}><a style={{fontWeight: \"bold\"}}>end if</a></div>\n                <div style={{textIndent: 15, backgroundColor: (props.step === 3)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>if</a> k(x) &#8805; k(y) <a style={{fontWeight: \"bold\"}}>then</a></div>\n                <div style={{textIndent: 30, backgroundColor: (props.step === 4)?\"yellow\" : \"white\"}}>k(y) &#8592; k(x) + 1</div>\n                <div style={{textIndent: 15, backgroundColor: (props.step === 5)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>else</a></div>\n                <div style={{textIndent: 30, backgroundColor: (props.step === 6)?\"yellow\" : \"white\"}}>j &#8592; &#8970;log<sub>2</sub>(min{\"{k(w) - k(v), d(w)}\"})&#8971; </div>\n                <div style={{textIndent: 30, backgroundColor: (props.step === 6)?\"yellow\" : \"white\"}}>c(j, y) &#8592; c(j, y) + 1</div>\n                <div style={{textIndent: 30, backgroundColor: (props.step === 8)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>if</a> c(j, y) = 3 * 2<sup>j</sup> <a style={{fontWeight: \"bold\"}}>then</a></div>\n                <div style={{textIndent: 45, backgroundColor: (props.step === 8)?\"yellow\" : \"white\"}}>c(j, y) &#8592; 0</div>\n                <div style={{textIndent: 45, backgroundColor: (props.step === 8)?\"yellow\" : \"white\"}}>k(y) &#8592; max{\"{k(y), b(j, y) + \"}2<sup>j</sup>{\"}\"}</div>\n                <div style={{textIndent: 45, backgroundColor: (props.step === 8)?\"yellow\" : \"white\"}}>b(j, y) &#8592; k(y)</div>\n                <div style={{textIndent: 30, fontWeight: \"bold\"}}>{\"end if\"}</div>\n                <div style={{textIndent: 15, fontWeight: \"bold\"}}>{\"end if\"}</div>\n                <div style={{textIndent: 15, backgroundColor: (props.step === 9)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>while</a> k<sub>out</sub>(top(out(y))) &#8804; k(y) <a style={{fontWeight: \"bold\"}}>do</a></div>\n                <div style={{textIndent: 30, backgroundColor: (props.step === 10)?\"yellow\" : \"white\"}}>o &#8592; extractMin(out(y))</div>\n                <div style={{textIndent: 30, backgroundColor: (props.step === 10)?\"yellow\" : \"white\"}}>T &#8592; T &#8746; {\"{o}\"} </div>\n                <div style={{textIndent: 15}}><a style={{fontWeight: \"bold\"}}>end while </a></div>\n                <div style={{textIndent: 15, backgroundColor: (props.step === 11)?\"yellow\" : \"white\"}}> k<sub>out</sub>(x, y) &#8592; k(y)</div>\n                <div style={{textIndent: 15, backgroundColor: (props.step === 11)?\"yellow\" : \"white\"}}> insert((x, y), out(x))</div>\n                <div style={{textIndent: 15, backgroundColor: (props.step === 12)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>return </a>False</div>\n            </div>\n        )\n    } else {\n        return (<div> </div>)\n    }\n}\n\nfunction DenseGraphSubprocedure(props) {\n    return(\n        <div>\n            <h3>Podprocedura:</h3>\n            <DenseGraphSubprocedurePseudocode\n                procedure={props.procedure}\n                step={props.step}\n            />\n        </div>\n    )\n}\n\nexport default DenseGraphSubprocedure;",{"ruleId":"137","replacedBy":"138"},{"ruleId":"139","replacedBy":"140"},{"ruleId":"141","severity":1,"message":"142","line":7,"column":8,"nodeType":"143","messageId":"144","endLine":7,"endColumn":27},{"ruleId":"145","severity":1,"message":"146","line":12,"column":99,"nodeType":"147","endLine":12,"endColumn":131},{"ruleId":"145","severity":1,"message":"146","line":12,"column":171,"nodeType":"147","endLine":12,"endColumn":203},{"ruleId":"145","severity":1,"message":"146","line":14,"column":43,"nodeType":"147","endLine":14,"endColumn":75},{"ruleId":"145","severity":1,"message":"146","line":15,"column":99,"nodeType":"147","endLine":15,"endColumn":131},{"ruleId":"145","severity":1,"message":"146","line":15,"column":160,"nodeType":"147","endLine":15,"endColumn":192},{"ruleId":"145","severity":1,"message":"146","line":16,"column":99,"nodeType":"147","endLine":16,"endColumn":131},{"ruleId":"145","severity":1,"message":"146","line":17,"column":99,"nodeType":"147","endLine":17,"endColumn":131},{"ruleId":"145","severity":1,"message":"146","line":17,"column":194,"nodeType":"147","endLine":17,"endColumn":226},{"ruleId":"145","severity":1,"message":"146","line":21,"column":99,"nodeType":"147","endLine":21,"endColumn":131},{"ruleId":"145","severity":1,"message":"146","line":21,"column":162,"nodeType":"147","endLine":21,"endColumn":194},{"ruleId":"145","severity":1,"message":"146","line":27,"column":100,"nodeType":"147","endLine":27,"endColumn":132},{"ruleId":"145","severity":1,"message":"146","line":27,"column":184,"nodeType":"147","endLine":27,"endColumn":216},{"ruleId":"145","severity":1,"message":"146","line":28,"column":100,"nodeType":"147","endLine":28,"endColumn":132},{"ruleId":"145","severity":1,"message":"146","line":32,"column":100,"nodeType":"147","endLine":32,"endColumn":132},{"ruleId":"145","severity":1,"message":"146","line":8,"column":103,"nodeType":"147","endLine":8,"endColumn":135},{"ruleId":"145","severity":1,"message":"146","line":14,"column":103,"nodeType":"147","endLine":14,"endColumn":135},{"ruleId":"145","severity":1,"message":"146","line":14,"column":156,"nodeType":"147","endLine":14,"endColumn":188},{"ruleId":"145","severity":1,"message":"146","line":15,"column":103,"nodeType":"147","endLine":15,"endColumn":135},{"ruleId":"145","severity":1,"message":"146","line":16,"column":47,"nodeType":"147","endLine":16,"endColumn":79},{"ruleId":"145","severity":1,"message":"146","line":18,"column":103,"nodeType":"147","endLine":18,"endColumn":135},{"ruleId":"145","severity":1,"message":"146","line":18,"column":203,"nodeType":"147","endLine":18,"endColumn":235},{"ruleId":"145","severity":1,"message":"146","line":19,"column":103,"nodeType":"147","endLine":19,"endColumn":135},{"ruleId":"145","severity":1,"message":"146","line":20,"column":47,"nodeType":"147","endLine":20,"endColumn":79},{"ruleId":"145","severity":1,"message":"146","line":21,"column":47,"nodeType":"147","endLine":21,"endColumn":79},{"ruleId":"145","severity":1,"message":"146","line":21,"column":142,"nodeType":"147","endLine":21,"endColumn":174},{"ruleId":"145","severity":1,"message":"146","line":22,"column":103,"nodeType":"147","endLine":22,"endColumn":135},{"ruleId":"145","severity":1,"message":"146","line":22,"column":170,"nodeType":"147","endLine":22,"endColumn":202},{"ruleId":"145","severity":1,"message":"146","line":23,"column":103,"nodeType":"147","endLine":23,"endColumn":135},{"ruleId":"145","severity":1,"message":"146","line":26,"column":104,"nodeType":"147","endLine":26,"endColumn":136},{"ruleId":"145","severity":1,"message":"146","line":26,"column":158,"nodeType":"147","endLine":26,"endColumn":190},{"ruleId":"145","severity":1,"message":"146","line":27,"column":104,"nodeType":"147","endLine":27,"endColumn":136},{"ruleId":"145","severity":1,"message":"146","line":27,"column":165,"nodeType":"147","endLine":27,"endColumn":197},{"ruleId":"145","severity":1,"message":"146","line":28,"column":104,"nodeType":"147","endLine":28,"endColumn":136},{"ruleId":"145","severity":1,"message":"146","line":28,"column":162,"nodeType":"147","endLine":28,"endColumn":194},{"ruleId":"145","severity":1,"message":"146","line":29,"column":104,"nodeType":"147","endLine":29,"endColumn":136},{"ruleId":"145","severity":1,"message":"146","line":29,"column":151,"nodeType":"147","endLine":29,"endColumn":183},{"ruleId":"145","severity":1,"message":"146","line":30,"column":47,"nodeType":"147","endLine":30,"endColumn":79},{"ruleId":"145","severity":1,"message":"146","line":31,"column":47,"nodeType":"147","endLine":31,"endColumn":79},{"ruleId":"145","severity":1,"message":"146","line":32,"column":104,"nodeType":"147","endLine":32,"endColumn":136},{"ruleId":"145","severity":1,"message":"146","line":39,"column":47,"nodeType":"147","endLine":39,"endColumn":79},{"ruleId":"145","severity":1,"message":"146","line":39,"column":107,"nodeType":"147","endLine":39,"endColumn":139},{"ruleId":"145","severity":1,"message":"146","line":41,"column":47,"nodeType":"147","endLine":41,"endColumn":79},{"ruleId":"145","severity":1,"message":"146","line":41,"column":133,"nodeType":"147","endLine":41,"endColumn":165},{"ruleId":"145","severity":1,"message":"146","line":42,"column":103,"nodeType":"147","endLine":42,"endColumn":135},{"ruleId":"145","severity":1,"message":"146","line":42,"column":154,"nodeType":"147","endLine":42,"endColumn":186},{"ruleId":"145","severity":1,"message":"146","line":43,"column":103,"nodeType":"147","endLine":43,"endColumn":135},{"ruleId":"145","severity":1,"message":"146","line":44,"column":47,"nodeType":"147","endLine":44,"endColumn":79},{"ruleId":"145","severity":1,"message":"146","line":45,"column":103,"nodeType":"147","endLine":45,"endColumn":135},{"ruleId":"145","severity":1,"message":"146","line":45,"column":164,"nodeType":"147","endLine":45,"endColumn":196},{"ruleId":"145","severity":1,"message":"146","line":47,"column":103,"nodeType":"147","endLine":47,"endColumn":135},{"ruleId":"145","severity":1,"message":"146","line":47,"column":169,"nodeType":"147","endLine":47,"endColumn":201},{"ruleId":"145","severity":1,"message":"146","line":51,"column":47,"nodeType":"147","endLine":51,"endColumn":79},{"ruleId":"145","severity":1,"message":"146","line":52,"column":47,"nodeType":"147","endLine":52,"endColumn":79},{"ruleId":"145","severity":1,"message":"146","line":53,"column":47,"nodeType":"147","endLine":53,"endColumn":79},{"ruleId":"145","severity":1,"message":"146","line":54,"column":103,"nodeType":"147","endLine":54,"endColumn":135},{"ruleId":"145","severity":1,"message":"146","line":61,"column":103,"nodeType":"147","endLine":61,"endColumn":135},{"ruleId":"145","severity":1,"message":"146","line":61,"column":164,"nodeType":"147","endLine":61,"endColumn":196},{"ruleId":"145","severity":1,"message":"146","line":63,"column":47,"nodeType":"147","endLine":63,"endColumn":79},{"ruleId":"145","severity":1,"message":"146","line":10,"column":99,"nodeType":"147","endLine":10,"endColumn":131},{"ruleId":"145","severity":1,"message":"146","line":10,"column":154,"nodeType":"147","endLine":10,"endColumn":186},{"ruleId":"145","severity":1,"message":"146","line":12,"column":99,"nodeType":"147","endLine":12,"endColumn":131},{"ruleId":"145","severity":1,"message":"146","line":12,"column":159,"nodeType":"147","endLine":12,"endColumn":191},{"ruleId":"145","severity":1,"message":"146","line":16,"column":43,"nodeType":"147","endLine":16,"endColumn":75},{"ruleId":"145","severity":1,"message":"146","line":19,"column":99,"nodeType":"147","endLine":19,"endColumn":131},{"ruleId":"145","severity":1,"message":"146","line":20,"column":43,"nodeType":"147","endLine":20,"endColumn":75},{"ruleId":"145","severity":1,"message":"146","line":22,"column":100,"nodeType":"147","endLine":22,"endColumn":132},{"ruleId":"145","severity":1,"message":"146","line":22,"column":160,"nodeType":"147","endLine":22,"endColumn":192},{"ruleId":"145","severity":1,"message":"146","line":24,"column":100,"nodeType":"147","endLine":24,"endColumn":132},{"ruleId":"145","severity":1,"message":"146","line":24,"column":165,"nodeType":"147","endLine":24,"endColumn":197},{"ruleId":"145","severity":1,"message":"146","line":25,"column":100,"nodeType":"147","endLine":25,"endColumn":132},{"ruleId":"145","severity":1,"message":"146","line":26,"column":43,"nodeType":"147","endLine":26,"endColumn":75},{"ruleId":"145","severity":1,"message":"146","line":27,"column":43,"nodeType":"147","endLine":27,"endColumn":75},{"ruleId":"145","severity":1,"message":"146","line":28,"column":100,"nodeType":"147","endLine":28,"endColumn":132},{"ruleId":"145","severity":1,"message":"146","line":8,"column":103,"nodeType":"147","endLine":8,"endColumn":135},{"ruleId":"145","severity":1,"message":"146","line":8,"column":148,"nodeType":"147","endLine":8,"endColumn":180},{"ruleId":"145","severity":1,"message":"146","line":9,"column":103,"nodeType":"147","endLine":9,"endColumn":135},{"ruleId":"145","severity":1,"message":"146","line":10,"column":47,"nodeType":"147","endLine":10,"endColumn":79},{"ruleId":"145","severity":1,"message":"146","line":11,"column":103,"nodeType":"147","endLine":11,"endColumn":135},{"ruleId":"145","severity":1,"message":"146","line":11,"column":160,"nodeType":"147","endLine":11,"endColumn":192},{"ruleId":"145","severity":1,"message":"146","line":13,"column":103,"nodeType":"147","endLine":13,"endColumn":135},{"ruleId":"145","severity":1,"message":"146","line":16,"column":103,"nodeType":"147","endLine":16,"endColumn":135},{"ruleId":"145","severity":1,"message":"146","line":16,"column":170,"nodeType":"147","endLine":16,"endColumn":202},{"ruleId":"145","severity":1,"message":"146","line":22,"column":103,"nodeType":"147","endLine":22,"endColumn":135},{"ruleId":"145","severity":1,"message":"146","line":22,"column":187,"nodeType":"147","endLine":22,"endColumn":219},{"ruleId":"145","severity":1,"message":"146","line":25,"column":47,"nodeType":"147","endLine":25,"endColumn":79},{"ruleId":"145","severity":1,"message":"146","line":28,"column":104,"nodeType":"147","endLine":28,"endColumn":136},"no-native-reassign",["148"],"no-negated-in-lhs",["149"],"no-unused-vars","'SparseGraphDemoStep' is defined but never used.","Identifier","unusedVar","jsx-a11y/anchor-is-valid","The href attribute is required for an anchor to be keyboard accessible. Provide a valid, navigable address as the href value. If you cannot provide an href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","JSXOpeningElement","no-global-assign","no-unsafe-negation"]