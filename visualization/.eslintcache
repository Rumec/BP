[{"/Users/rumec/Documents/Škola/learning-react/src/index.js":"1","/Users/rumec/Documents/Škola/learning-react/src/reportWebVitals.js":"2","/Users/rumec/Documents/Škola/learning-react/src/App.js":"3","/Users/rumec/Documents/Škola/learning-react/src/components/MyInfo.js":"4","/Users/rumec/Documents/Škola/learning-react/src/components/Footer.js":"5","/Users/rumec/Documents/Škola/learning-react/src/components/Header.js":"6","/Users/rumec/Documents/Škola/learning-react/src/components/MainContent.js":"7","/Users/rumec/Documents/Škola/learning-react/src/components/ToDoItem.js":"8","/Users/rumec/Documents/Škola/learning-react/src/components/ContactCard.js":"9","/Users/rumec/Documents/Škola/learning-react/src/components/Joke.js":"10","/Users/rumec/Documents/Škola/learning-react/src/components/jokesData.js":"11","/Users/rumec/Documents/Škola/learning-react/src/components/products.js":"12","/Users/rumec/Documents/Škola/learning-react/src/components/Product.js":"13","/Users/rumec/Documents/Škola/learning-react/src/components/todosData.js":"14","/Users/rumec/Documents/Škola/learning-react/src/components/Checkbox.js":"15","/Users/rumec/Documents/Škola/learning-react/src/components/Conditional.js":"16","/Users/rumec/Documents/Škola/learning-react/src/components/FormComponentRender.js":"17","/Users/rumec/Documents/Škola/learning-react/src/components/FormCoontainer.js":"18","/Users/rumec/Documents/Škola/learning-react/src/components/Chart1.js":"19","/Users/rumec/Documents/Škola/BP/visualization/src/index.js":"20","/Users/rumec/Documents/Škola/BP/visualization/src/App.js":"21","/Users/rumec/Documents/Škola/BP/visualization/src/reportWebVitals.js":"22","/Users/rumec/Documents/Škola/BP/visualization/src/components/Chart1.js":"23","/Users/rumec/Documents/Škola/BP/visualization/src/components/DFS.js":"24","/Users/rumec/Documents/Škola/BP/visualization/src/components/SparseGraph.js":"25","/Users/rumec/Documents/Škola/BP/visualization/src/components/SparseGraphPseudocode.js":"26","/Users/rumec/Documents/Škola/BP/visualization/src/components/SparseGraphSubprocedure.js":"27"},{"size":923,"mtime":1612028114381,"results":"28","hashOfConfig":"29"},{"size":362,"mtime":1608018658623,"results":"30","hashOfConfig":"29"},{"size":3637,"mtime":1613084319319,"results":"31","hashOfConfig":"29"},{"size":368,"mtime":1608021344546,"results":"32","hashOfConfig":"29"},{"size":197,"mtime":1608034028866,"results":"33","hashOfConfig":"29"},{"size":1059,"mtime":1608274834579,"results":"34","hashOfConfig":"29"},{"size":275,"mtime":1612028570628,"results":"35","hashOfConfig":"29"},{"size":997,"mtime":1612710174809,"results":"36","hashOfConfig":"29"},{"size":365,"mtime":1612200035188,"results":"37","hashOfConfig":"29"},{"size":317,"mtime":1612213846659,"results":"38","hashOfConfig":"29"},{"size":428,"mtime":1608656310496,"results":"39","hashOfConfig":"29"},{"size":653,"mtime":1608658359035,"results":"40","hashOfConfig":"29"},{"size":296,"mtime":1612218393511,"results":"41","hashOfConfig":"29"},{"size":469,"mtime":1608718255137,"results":"42","hashOfConfig":"29"},{"size":192,"mtime":1611925183614,"results":"43","hashOfConfig":"29"},{"size":198,"mtime":1612636005760,"results":"44","hashOfConfig":"29"},{"size":3104,"mtime":1612891780699,"results":"45","hashOfConfig":"29"},{"size":1502,"mtime":1612892212138,"results":"46","hashOfConfig":"29"},{"size":8876,"mtime":1613503835755,"results":"47","hashOfConfig":"29"},{"size":923,"mtime":1612028114381,"results":"48","hashOfConfig":"49"},{"size":3637,"mtime":1613084319319,"results":"50","hashOfConfig":"49"},{"size":362,"mtime":1608018658623,"results":"51","hashOfConfig":"49"},{"size":27835,"mtime":1614457149855,"results":"52","hashOfConfig":"49"},{"size":1082,"mtime":1613677065544,"results":"53","hashOfConfig":"49"},{"size":6722,"mtime":1613763122930,"results":"54","hashOfConfig":"49"},{"size":3604,"mtime":1614458481104,"results":"55","hashOfConfig":"49"},{"size":7297,"mtime":1614458781630,"results":"56","hashOfConfig":"49"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"59"},"14m7js0",{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"59"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"59"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"66","messages":"67","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"68"},{"filePath":"69","messages":"70","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"68"},{"filePath":"71","messages":"72","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"68"},{"filePath":"73","messages":"74","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"68"},{"filePath":"75","messages":"76","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"77","messages":"78","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"79","usedDeprecatedRules":"68"},{"filePath":"80","messages":"81","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"68"},{"filePath":"82","messages":"83","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"68"},{"filePath":"84","messages":"85","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"68"},{"filePath":"86","messages":"87","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"68"},{"filePath":"88","messages":"89","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"68"},{"filePath":"90","messages":"91","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"92","messages":"93","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"94"},{"filePath":"95","messages":"96","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"94"},{"filePath":"97","messages":"98","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"99","messages":"100","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"101"},"15ryza8",{"filePath":"102","messages":"103","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"101"},{"filePath":"104","messages":"105","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"101"},{"filePath":"106","messages":"107","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"108","usedDeprecatedRules":"101"},{"filePath":"109","messages":"110","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"111","messages":"112","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"113"},{"filePath":"114","messages":"115","errorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"116","usedDeprecatedRules":"101"},{"filePath":"117","messages":"118","errorCount":0,"warningCount":40,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"/Users/rumec/Documents/Škola/learning-react/src/index.js",[],["119","120"],"/Users/rumec/Documents/Škola/learning-react/src/reportWebVitals.js",[],"/Users/rumec/Documents/Škola/learning-react/src/App.js",[],"/Users/rumec/Documents/Škola/learning-react/src/components/MyInfo.js",[],"/Users/rumec/Documents/Škola/learning-react/src/components/Footer.js",[],["121","122"],"/Users/rumec/Documents/Škola/learning-react/src/components/Header.js",[],"/Users/rumec/Documents/Škola/learning-react/src/components/MainContent.js",[],"/Users/rumec/Documents/Škola/learning-react/src/components/ToDoItem.js",[],"/Users/rumec/Documents/Škola/learning-react/src/components/ContactCard.js",["123"],"/Users/rumec/Documents/Škola/learning-react/src/components/Joke.js",["124"],"import React from 'react';\n\nfunction Joke(props) {\n    return(\n        <div>\n            <h1>Joke: </h1>\n            <p style={{display: (props.question == undefined)? \"none\" : \"block\"}}>Question: {props.question}</p>\n            <p>{props.punchLine}</p>\n            <hr/>\n        </div>\n    )\n}\n\nexport default Joke;","/Users/rumec/Documents/Škola/learning-react/src/components/jokesData.js",[],"/Users/rumec/Documents/Škola/learning-react/src/components/products.js",[],"/Users/rumec/Documents/Škola/learning-react/src/components/Product.js",[],"/Users/rumec/Documents/Škola/learning-react/src/components/todosData.js",[],"/Users/rumec/Documents/Škola/learning-react/src/components/Checkbox.js",[],"/Users/rumec/Documents/Škola/learning-react/src/components/Conditional.js",[],"/Users/rumec/Documents/Škola/learning-react/src/components/FormComponentRender.js",[],["125","126"],"/Users/rumec/Documents/Škola/learning-react/src/components/FormCoontainer.js",[],"/Users/rumec/Documents/Škola/learning-react/src/components/Chart1.js",[],"/Users/rumec/Documents/Škola/BP/visualization/src/index.js",[],["127","128"],"/Users/rumec/Documents/Škola/BP/visualization/src/App.js",[],"/Users/rumec/Documents/Škola/BP/visualization/src/reportWebVitals.js",[],"/Users/rumec/Documents/Škola/BP/visualization/src/components/Chart1.js",["129","130"],"import React from \"react\";\nimport Graph from \"react-graph-vis\";\nimport './graphStyle.css';\nimport SparseGraphPseudocode from \"./SparseGraphPseudocode\";\nimport SparseGraphSubprocedure from \"./SparseGraphSubprocedure\";\n//import DFS from \"./DFS\";\n//import SparseGraph from \"./SparseGraph\";\n\nconst RADIUS = 200;\n\nclass NetworkGraph extends React.Component {\n    constructor(props) {\n        super(props);\n        this.visited = [];\n        this.status = {\n            LESS_THAN_DELTA_EDGES: 0,\n            CYCLE_FOUND: 1,\n            MORE_THAN_DELTA_EDGES: 2\n        }\n\n        this.state = {\n            subprocedure: 0,\n            subprocedureStep: 0,\n            mainProcedureStep: 0,\n            timeoutInput: 500,\n            timeout: 500,\n            followerList: {},\n\n            e_in: {}, // JSON of lists in incoming edges\n            delta: 0,\n\n            inProgress: false,\n            visited: [],\n            addingEdge: false,\n            from: 0,\n            to: 0,\n            numberOfVertices: 0,\n            nodes: [],\n            edges: []\n        };\n        this.handleChange = this.handleChange.bind(this);\n        this.generateGraph = this.generateGraph.bind(this);\n        this.addEdge = this.addEdge.bind(this);\n        this.changeVertex = this.changeVertex.bind(this);\n        this.colorEdge = this.colorEdge.bind(this);\n        this.colorGraphToDefault = this.colorGraphToDefault.bind(this);\n        this.changeProgress = this.changeProgress.bind(this);\n        this.addVisitedVertex = this.addVisitedVertex.bind(this);\n        this.clearVisitedVertices = this.clearVisitedVertices.bind(this);\n        this.setTimeoutFromInput = this.setTimeoutFromInput.bind(this);\n        this.addVertexToEin = this.addVertexToEin.bind(this);\n        this.setEinOfVertex = this.setEinOfVertex.bind(this);\n        this.setDelta = this.setDelta.bind(this);\n        this.setMainProcedureStep = this.setMainProcedureStep.bind(this);\n        this.setSubprocedureStep = this.setSubprocedureStep.bind(this);\n    }\n\n    async setSubprocedureStep(subprocedure, step) {\n        await this.setState({\n            subprocedure: subprocedure,\n            subprocedureStep: step\n        })\n    }\n\n    async setMainProcedureStep(step) {\n        await this.setState({\n            mainProcedureStep: step\n        })\n    }\n\n    /**\n     * Sets new value of delta\n     *\n     * @param value - New value to be set\n     * @returns {Promise<void>}\n     */\n    async setDelta(value) {\n        await this.setState({\n            delta: value\n        })\n    }\n\n    /**\n     * Adds a vertex to the e_in set\n     *\n     * @param successor - Vertex which e_in should be expanded\n     * @param predecessor - Vertex to be added\n     * @returns {Promise<void>}\n     */\n    async addVertexToEin(successor, predecessor) {\n        const oldEin = await this.state.e_in;\n        await oldEin[successor].push(predecessor);\n        await this.setState({\n            e_in: oldEin,\n        });\n    }\n\n    /**\n     * Sets the set of incoming edges to be the value given as parameter\n     *\n     * @param vertex - ID of vertex which e_in should be changed\n     * @param toBeSet - New value of e_in\n     * @returns {Promise<void>}\n     */\n    async setEinOfVertex(vertex, toBeSet) {\n        await this.setState(async prevState => {\n            prevState.e_in[vertex] = await toBeSet;\n            return prevState;\n        })\n    }\n\n    /**\n     * Handles changes of the controllers\n     *\n     * @param event - Object returned by event\n     */\n    handleChange(event) {\n        const {name, type, value, checked} = event.target;\n\n        //if (name === \"from\" || name === \"to\") {\n        this.setState({\n            [name]: parseInt(value)\n        })\n        //}\n\n        /*\n        (type === \"checkbox\") ? this.setState({[name]: checked})\n            : (name === \"addingEdge\") ? this.setState(prevState => {\n                return {\n                    addingEdge: !prevState.addingEdge\n                }\n            })\n            : this.setState({[name]: value});\n\n         */\n    }\n\n    /**\n     * Generates new graph, sets levels of all vertices to 1\n     *\n     * @returns {Promise<void>}\n     */\n    async generateGraph() {\n        let actualAngle = 0;\n        let nodesArr = [];\n        let followerList = {};\n        let e_in = {};\n        for (let i = 1; i <= this.state.numberOfVertices; ++i) {\n            await nodesArr.push({\n                id: i,\n                level: 1,\n                label: i.toString() + \", 1\",\n                title: i.toString(),\n                color: \"#34e1eb\",\n                x: RADIUS * Math.sin(actualAngle),\n                y: RADIUS * Math.cos(actualAngle)\n            });\n            followerList[i] = [];\n            e_in[i] = []; // initializing list of incoming edges\n            actualAngle += await (2 * Math.PI) / (this.state.numberOfVertices);\n        }\n        await this.setState({\n            mainProcedureStep: 0,\n            followerList: followerList,\n            e_in: e_in,\n            nodes: nodesArr,\n            edges: [],\n            delta: 0\n        });\n        //console.log(this.state.nodes);\n    }\n\n    /**\n     * Adds new edge to graph\n     *\n     * @returns {Promise<void>}\n     */\n    async addEdge() {\n        const from = parseInt(this.state.from);\n        const to = parseInt(this.state.to);\n\n        const oldEdges = await this.state.edges.slice();\n        await oldEdges.push({\n            from: from,\n            to: to,\n            color: \"black\",\n            width: 3\n        });\n\n        const oldFollowerList = await this.state.followerList;\n        await oldFollowerList[from].push(to);\n        await this.setState({\n            followerList: oldFollowerList,\n            edges: oldEdges,\n        });\n    }\n\n    DisplayAddingStatus() {\n        if (this.state.addingEdge && this.state.from === 0) {\n            return (\n                <p>Select starting vertex</p>\n            );\n        } else if (this.state.addingEdge && this.state.from !== 0) {\n            return (\n                <p>Select ending vertex</p>\n            );\n        } else {\n            return (<p>doing nothing</p>);\n        }\n    }\n\n    /**\n     * Action performed after node is selected via mouse click\n     *\n     * @param event - Event provided by mouse click\n     * @returns {Promise<void>}\n     */\n    async selectVertex(event) {\n        const {nodes} = event;\n\n        if (this.state.addingEdge && this.state.from !== 0) {\n            await this.setState({\n                to: nodes[0],\n                addingEdge: false\n            });\n            //await this.addEdge();\n        }\n        await this.setState({\n            from: nodes[0]\n        })\n\n    }\n\n    /**\n     * Stops program for specified amount of time\n     *\n     * @param sleepTime - Time to sleep\n     * @returns {Promise<unknown>}\n     */\n    sleepNow = (sleepTime) => new Promise((r) => setTimeout(r, sleepTime));\n\n    /**\n     * Changing parameters of vertex with given id to specified attributes\n     *\n     * @param id - ID of the node to be changed\n     * @param color - Color to be set\n     * @param levelIncrease - Value by which nodes level should be increased\n     * @returns {Promise<void>}\n     */\n    async changeVertex(id, color, levelIncrease) {\n        await this.setState(prevState => {\n            prevState.nodes = prevState.nodes.map(node => {\n                if (node.id === id) {\n                    return {\n                        id: id,\n                        level: node.level + levelIncrease,\n                        label: id.toString() + \", \" + (node.level + levelIncrease).toString(),\n                        title: node.title,\n                        color: color\n                    }\n                }\n                return node;\n            })\n            return {\n                nodes: prevState.nodes\n            };\n        })\n    }\n\n    /**\n     * Changes inProgress flag\n     */\n    changeProgress() {\n        this.setState(prevState => {\n            return {\n                inProgress: !prevState.inProgress\n            };\n        })\n    }\n\n    /**\n     * Adds vertex to set of visited vertices\n     *\n     * @param vertex - ID of vertex to be added\n     * @returns {Promise<void>}\n     */\n    async addVisitedVertex(vertex) {\n        await this.setState(prevState => {\n            prevState.visited.push(vertex);\n            return prevState;\n        })\n    }\n\n    /**\n     * Clears set of visited vertices\n     *\n     * @returns {Promise<void>}\n     */\n    async clearVisitedVertices() {\n        await this.setState({\n            visited: []\n        })\n    }\n\n    /**\n     * Colors given edge to red color (used for animation of searching through edges)\n     *\n     * @param from - Starting vertex of edge\n     * @param to - Ending vertex of edge\n     * @param color - Color of the edge\n     * @returns {Promise<void>}\n     */\n    async colorEdge(from, to, color) {\n        let oldEdges = await this.state.edges.slice();\n        const index = oldEdges.findIndex(item =>\n            item.from === from && item.to === to\n        );\n        await oldEdges.splice(index, 1);\n        await oldEdges.push({\n                from: from,\n                to: to,\n                color: color,\n                width: 3\n            }\n        )\n        await this.setState({\n            edges: oldEdges,\n        });\n    }\n\n    /**\n     * Colors whole graph back to default colors\n     *\n     * @returns {Promise<void>}\n     */\n    async colorGraphToDefault() {\n        /**\n         * Coloring all edges back to black\n         */\n        let oldEdges = await this.state.edges.slice();\n        for (let i = 0; i < oldEdges.length; ++i) {\n            let tmpEdge = {\n                from: oldEdges[0].from,\n                to: oldEdges[0].to,\n                color: \"black\",\n                width: 3\n            };\n\n            await oldEdges.splice(0, 1);\n            await oldEdges.push(tmpEdge);\n        }\n\n        await this.setState({\n            edges: oldEdges,\n        });\n\n        /**\n         * Coloring all vertices to default\n         */\n        await this.setState(prevState => {\n            prevState.nodes = prevState.nodes.map(node => {\n                node = {\n                    id: node.id,\n                    level: node.level,\n                    label: node.label,\n                    title: node.title,\n                    color: \"#34e1eb\"\n                }\n                return node;\n            })\n            return {\n                nodes: prevState.nodes\n            };\n        })\n    }\n\n    /**\n     * Sets value of pause using value in number input\n     */\n    setTimeoutFromInput() {\n        this.setState({\n            timeout: this.state.timeoutInput\n        })\n    }\n\n\n    /**************************/\n\n    /**\n     * Main procedure of algorithm for sparse graphs\n     *\n     * @returns {Promise<boolean>}\n     */\n    async insertEdge() {\n        let forward = false;\n        let actualStatus;\n\n        let fromVertex = this.state.nodes[this.state.nodes.findIndex(node => node.id === this.state.from)],\n            toVertex = this.state.nodes[this.state.nodes.findIndex(node => node.id === this.state.to)];\n\n        await this.changeVertex(fromVertex.id, \"orange\", 0);\n        await this.changeVertex(toVertex.id, \"orange\", 0);\n\n        await this.setMainProcedureStep(1);\n        await this.sleepNow(this.state.timeout);\n\n        await console.log(\"fromVertex:\", fromVertex, \"toVertex:\", toVertex);\n\n        if (!(await this.testOrdering(this.state.from, this.state.to))) {\n\n            actualStatus = await this.backwardSearch(fromVertex.id, toVertex.id);\n            console.log(\"actual status:\", actualStatus);\n            if (actualStatus === this.status.CYCLE_FOUND) {\n\n                await this.setMainProcedureStep(4);\n                await this.sleepNow(this.state.timeout);\n                await this.setMainProcedureStep(5);\n                await this.sleepNow(this.state.timeout);\n                await this.setMainProcedureStep(0);\n\n                return true;\n            } else if (actualStatus === this.status.LESS_THAN_DELTA_EDGES && (toVertex.level < fromVertex.level)) {\n\n                await this.setMainProcedureStep(6);\n                await this.sleepNow(this.state.timeout);\n                await this.setMainProcedureStep(7);\n                await this.sleepNow(this.state.timeout);\n\n                await this.changeVertex(toVertex.id, \"orange\", (fromVertex.level - toVertex.level));\n                await this.setEinOfVertex(toVertex.id, []);\n                forward = true;\n            } else if (actualStatus === this.status.MORE_THAN_DELTA_EDGES) {\n\n                await this.setMainProcedureStep(8);\n                await this.sleepNow(this.state.timeout);\n                await this.setMainProcedureStep(9);\n                await this.sleepNow(this.state.timeout);\n\n                await this.changeVertex(toVertex.id, \"orange\", ((fromVertex.level - toVertex.level) + 1));\n                await this.setEinOfVertex(toVertex.id, []);\n                await this.clearVisitedVertices();\n                await this.addVisitedVertex(fromVertex.id);\n                forward = true;\n            }\n\n            if (forward) {\n                await this.setMainProcedureStep(10);\n                await this.setSubprocedureStep(3, 0);\n                await this.sleepNow(this.state.timeout);\n\n                actualStatus = (await this.forwardSearch(this.state.to));\n                if (actualStatus) {\n                    await this.setMainProcedureStep(11);\n                    await this.sleepNow(this.state.timeout);\n                    await this.setMainProcedureStep(0);\n\n                    return true;\n                }\n            }\n        }\n\n        await this.colorGraphToDefault();\n\n        await this.setMainProcedureStep(12);\n        await this.sleepNow(this.state.timeout);\n\n        await this.addingEdge(fromVertex.id, toVertex.id);\n        await this.clearVisitedVertices();\n        await this.setMainProcedureStep(0);\n        await this.setSubprocedureStep(0, 0);\n        return false;\n    }\n\n    async testOrdering(from, to) {\n        let fromLevel = this.state.nodes[this.state.nodes.findIndex(node => node.id === from)].level,\n            toLevel = this.state.nodes[this.state.nodes.findIndex(node => node.id === to)].level;\n\n        await this.setMainProcedureStep(2);\n        await this.setSubprocedureStep(1, 0);\n        await this.sleepNow(this.state.timeout);\n        await this.setSubprocedureStep(1, 1);\n        await this.sleepNow(this.state.timeout);\n        await this.setSubprocedureStep(0, 0);\n        return (fromLevel < toLevel);\n    }\n\n    async backwardSearch(start, w) {\n        await this.setMainProcedureStep(3);\n        await this.setSubprocedureStep(2, 0);\n        await this.sleepNow(this.state.timeout);\n        await this.setSubprocedureStep(2, 1);\n        await this.sleepNow(this.state.timeout);\n\n        if (start === w) {\n            await this.setSubprocedureStep(2, 2);\n            await this.sleepNow(this.state.timeout);\n\n            return this.status.CYCLE_FOUND;\n        }\n        await this.setSubprocedureStep(2, 3);\n        await this.sleepNow(this.state.timeout);\n\n        await this.addVisitedVertex(start);\n\n        for (let i = 0; i < this.state.e_in[start].length; ++i) {\n            let predecessor = await this.state.e_in[start][i];\n\n            await this.setSubprocedureStep(2, 3);\n            await this.sleepNow(this.state.timeout);\n\n            if (this.state.visited.length > this.state.delta /* + 1 */) {\n\n                await this.setSubprocedureStep(2, 5);\n                await this.sleepNow(this.state.timeout);\n                await this.setSubprocedureStep(0, 0);\n\n                return this.status.MORE_THAN_DELTA_EDGES;\n            }\n\n            if (this.state.visited.includes(predecessor)) {\n                continue;\n            }\n\n            // Coloring backward-searched edges\n            //console.log(\"Searching backwards edge: (\", predecessor, \", \", start, \")\");\n            await this.colorEdge(predecessor, start, \"red\");\n            await this.setSubprocedureStep(2, 6);\n            await this.sleepNow(this.state.timeout);\n            let actualStatus = await this.backwardSearch(predecessor, w);\n\n            await this.setSubprocedureStep(2, 7);\n            await this.sleepNow(this.state.timeout);\n            if (actualStatus === this.status.CYCLE_FOUND || actualStatus === this.status.MORE_THAN_DELTA_EDGES) {\n                if (actualStatus === this.status.CYCLE_FOUND) {\n                    await this.setSubprocedureStep(2, 8);\n                    await this.sleepNow(this.state.timeout);\n                } else if (actualStatus === this.status.MORE_THAN_DELTA_EDGES) {\n                    await this.setSubprocedureStep(2, 9);\n                    await this.sleepNow(this.state.timeout);\n                }\n                await this.setSubprocedureStep(0, 0);\n                return actualStatus;\n            }\n            await this.setSubprocedureStep(2, 10);\n            await this.sleepNow(this.state.timeout);\n        }\n        await this.setSubprocedureStep(2, 11);\n        await this.sleepNow(this.state.timeout);\n        await this.setSubprocedureStep(0, 0);\n        return this.status.LESS_THAN_DELTA_EDGES;\n    }\n\n    async forwardSearch(w) {\n        // Simulation of set (JS set is not very smart)\n        await this.setSubprocedureStep(3, 1);\n        await this.sleepNow(this.state.timeout);\n\n        let F = [w];\n\n        while (F.length) {\n            await this.setSubprocedureStep(3, 2);\n            await this.sleepNow(this.state.timeout);\n\n            let actual = await F.pop();\n            actual = this.state.nodes[this.state.nodes.findIndex(node => node.id === actual)];\n\n            for (let i = 0; i < this.state.followerList[actual.id].length; ++i) {\n\n                let successor = await this.state.followerList[actual.id][i];\n                successor = this.state.nodes[this.state.nodes.findIndex(node => node.id === successor)];\n\n                // Animation\n                //console.log(\"Searching forward edge: (\", actual.id, \", \", successor.id, \")\");\n                await this.colorEdge(actual.id, successor.id, \"blue\");\n                await this.setSubprocedureStep(3, 3);\n                await this.sleepNow(this.state.timeout);\n\n                if (this.state.visited.includes(successor.id)) {\n                    await this.setSubprocedureStep(3, 4);\n                    await this.sleepNow(this.state.timeout);\n                    await this.setSubprocedureStep(0, 0);\n\n                    return true;\n                }\n\n                if (actual.level === successor.level) {\n                    await this.setSubprocedureStep(3, 5);\n                    await this.sleepNow(this.state.timeout);\n                    await this.setSubprocedureStep(3, 6);\n                    await this.sleepNow(this.state.timeout);\n\n                    await this.addVertexToEin(successor.id, actual.id);\n                } else if (actual.level > successor.level) {\n                    await this.setSubprocedureStep(3, 7);\n                    await this.sleepNow(this.state.timeout);\n                    await this.setSubprocedureStep(3, 8);\n                    await this.sleepNow(this.state.timeout);\n\n                    await this.changeVertex(successor.id, successor.color, (actual.level - successor.level));\n                    await this.setEinOfVertex(successor.id, [actual.id]);\n                    await F.push(successor.id);\n                }\n            }\n        }\n        await this.setSubprocedureStep(3, 9);\n        await this.sleepNow(this.state.timeout);\n        await this.setSubprocedureStep(0, 0);\n\n        return false;\n    }\n\n    async addingEdge(from, to) {\n\n        from = this.state.nodes[this.state.nodes.findIndex(node => node.id === from)];\n        to = this.state.nodes[this.state.nodes.findIndex(node => node.id === to)];\n\n        await this.setSubprocedureStep(4, 1);\n        await this.sleepNow(this.state.timeout);\n\n        await this.addEdge();\n\n        if (from.level === to.level) {\n            await this.setSubprocedureStep(4, 2);\n            await this.sleepNow(this.state.timeout);\n            await this.setSubprocedureStep(4, 3);\n            await this.sleepNow(this.state.timeout);\n\n            await this.addVertexToEin(to.id, from.id);\n        }\n        await this.setSubprocedureStep(4, 4);\n        await this.sleepNow(this.state.timeout);\n\n        await this.setDelta(await Math.min(await Math.sqrt(this.state.edges.length),\n            await Math.pow(this.state.nodes.length, (2 / 3))));\n\n        await this.setSubprocedureStep(0, 0);\n    }\n\n    async mainProcedure() {\n        if (!this.state.inProgress) {\n            const from = parseInt(this.state.from);\n            const to = parseInt(this.state.to);\n\n            await this.changeProgress();\n\n            if (to === from) {\n                window.alert(\"Cannot create loop\");\n            } else if (this.state.edges.some(edge => edge.from === from && edge.to === to)) {\n                window.alert(\"Edge already exists!\");\n            } else if (from > this.state.numberOfVertices || to > this.state.numberOfVertices ||\n                from < 1 || to < 1) {\n                await window.alert(\"Chosen vertices do not exist in the graph!\");\n            } else if (await this.insertEdge()) {\n                // Adding edge which creates cycle (green color)\n                await this.addEdge();\n                await this.colorEdge(this.state.from, this.state.to, \"green\");\n\n                await console.log(\"cycle\");\n                await window.alert(\"Cycle detected!\");\n            }\n\n            await this.changeProgress();\n        }\n\n    }\n\n    /**************************/\n\n    render() {\n        const graph = {nodes: this.state.nodes, edges: this.state.edges};\n\n        const options = {\n            layout: {\n                //hierarchical: true\n            },\n            edges: {\n                color: \"#000000\"\n            },\n            physics: {\n                enabled: false\n            },\n            height: \"500px\",\n        };\n\n        const events = {\n            // arrow function can access scope of whole component class\n            selectNode: async (event) => {\n                await this.selectVertex(event)\n            },\n\n            dragStart: async (event) => {\n                await this.selectVertex(event)\n            }\n        };\n        return (\n            <div>\n                <div\n                    className={\"graphLayout\"}\n                >\n                    <div\n                        className={\"graphBox\"}\n                    >\n                        <Graph\n                            graph={graph}\n                            options={options}\n                            events={events}\n                        />\n                    </div>\n\n                    <div\n                        className={\"pseudoCode\"}\n                    >\n                        <SparseGraphPseudocode step={this.state.mainProcedureStep}/>\n                    </div>\n\n                    <div\n                        className={\"procedure\"}\n                    >\n                        <SparseGraphSubprocedure\n                            procedure={this.state.subprocedure}\n                            step={this.state.subprocedureStep}\n                        />\n                    </div>\n\n                </div>\n                <input\n                    name={\"numberOfVertices\"}\n                    type={\"number\"}\n                    value={this.state.numberOfVertices}\n                    onChange={this.handleChange}\n                />\n                <button\n                    onClick={(!this.state.inProgress) ? this.generateGraph : () => {\n                    }}\n                >\n                    Generuj graf\n                </button>\n\n                <br/>\n\n\n                <p>adding edge from {this.state.from} to {this.state.to}</p>\n\n\n                <br/>\n\n                <div>\n                    <label>\n                        <input\n                            name={\"from\"}\n                            type={\"number\"}\n                            value={this.state.from}\n                            onChange={(!this.state.inProgress) ? this.handleChange : () => {\n                            }}\n                        />\n                        from\n                    </label>\n\n                    <label>\n                        <input\n                            name={\"to\"}\n                            type={\"number\"}\n                            value={this.state.to}\n                            onChange={(!this.state.inProgress) ? this.handleChange : () => {\n                            }}\n                        />\n                        to\n                    </label>\n\n                    <button\n                        onClick={() => {\n                            this.mainProcedure();\n                        }}\n                    >\n                        Add edge\n                    </button>\n                </div>\n\n\n                <br/>\n                <br/>\n                <label>\n                    <input\n                        name={\"timeoutInput\"}\n                        type={\"number\"}\n                        value={this.state.timeoutInput}\n                        onChange={this.handleChange}\n                    />\n                    Timeout\n                </label>\n                <button\n                    onClick={this.setTimeoutFromInput}\n                >\n                    Set timeout\n                </button>\n            </div>\n\n        )\n    }\n}\n\nexport default NetworkGraph;\n\n\n/*\n                <DFS\n                    state={this.state}\n                    changeProgress={this.changeProgress}\n                    colorGraphToDefault={this.colorGraphToDefault}\n                    sleepNow={this.sleepNow}\n                    visited={this.visited}\n                    colorEdgeToRed={this.colorEdgeToRed}\n                    changeVertex={this.changeVertex}\n                    addVisitedVertices={this.addVisitedVertex}\n                    clearVisitedVertices={this.clearVisitedVertices}\n                />\n\n                <button\n                    name={\"addingEdge\"}\n                    onClick={(!this.state.inProgress) ? this.handleChange : () => {\n                    }}\n                >\n                    Add edge with mouse\n                </button>\n\n                {this.DisplayAddingStatus()}\n\n                <button\n                    name={\"addingEdge\"}\n                    onClick={(!this.state.inProgress) ? this.handleChange : () => {\n                    }}\n                >\n                    Add edge with mouse\n                </button>\n\n                 <button\n                    onClick={(!this.state.inProgress) ? this.addEdge : () => {\n                    }}\n                >\n                    Add edge\n                </button>\n\n\n\n                <SparseGraph\n                    state={this.state}\n                    sleepNow={this.sleepNow}\n                    handleChange={this.handleChange}\n                    colorGraphToDefault={this.colorGraphToDefault}\n                    colorEdgeToRed={this.colorEdgeToRed}\n                    changeProgress={this.changeProgress}\n                    changeVertex={this.changeVertex}\n                    addVisitedVertex={this.addVisitedVertex}\n                    clearVisitedVertices={this.clearVisitedVertices}\n                    addVertexToEin={this.addVertexToEin}\n                    setEinOfVertex={this.setEinOfVertex}\n                    addEdge={this.addEdge}\n                    incrementM={this.incrementM}\n                    setDelta={this.setDelta}\n                />\n */","/Users/rumec/Documents/Škola/BP/visualization/src/components/DFS.js",[],"/Users/rumec/Documents/Škola/BP/visualization/src/components/SparseGraph.js",[],["131","132"],"/Users/rumec/Documents/Škola/BP/visualization/src/components/SparseGraphPseudocode.js",["133","134","135","136","137","138","139","140","141","142","143","144","145"],"import React from \"react\";\n\nfunction SparseGraphPseudocode(props) {\n    return (\n        <div>\n                <h3>Hlavni procedura:</h3>\n\n            <div style={{fontWeight: \"bold\"}}>function VlozeniHrany(Graf, hrana)</div>\n            <div style={{textIndent: 15, backgroundColor: (props.step === 1)?\"yellow\" : \"white\"}}>{\"v, w = hrana\"}</div>\n            <div style={{textIndent: 15, backgroundColor: (props.step === 1)?\"yellow\" : \"white\"}}>{\"B = {}\"}</div>\n            <div style={{textIndent: 15, backgroundColor: (props.step === 1)?\"yellow\" : \"white\"}}>{\"dopredny = False\"}</div>\n            <div style={{textIndent: 15, backgroundColor: (props.step === 2)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>if</a>{\" !TestUsporadani(Graf, v, w) \"}<a style={{fontWeight: \"bold\"}}>then</a></div>\n            <div style={{textIndent: 30, backgroundColor: (props.step === 3)?\"yellow\" : \"white\"}}>{\"s = ZpetnyPruzkum(Graf, v, w, b)\"}</div>\n            <div style={{textIndent: 30, backgroundColor: (props.step === 4)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>if</a>{\" s == CyklusNalezen \"}<a style={{fontWeight: \"bold\"}}>then</a></div>\n            <div style={{textIndent: 45, backgroundColor: (props.step === 5)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>return</a>{\" True\"}</div>\n            <div style={{textIndent: 30, backgroundColor: (props.step === 6)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>else if</a>{\" s == Neprekroceno && Graf.k(v) < Graf.k(w) \"}<a style={{fontWeight: \"bold\"}}>then</a></div>\n            <div style={{textIndent: 45, backgroundColor: (props.step === 7)?\"yellow\" : \"white\"}}>{\"Graf.k(w) = Graf.k(v)\"}</div>\n            <div style={{textIndent: 45, backgroundColor: (props.step === 7)?\"yellow\" : \"white\"}}>{\"Graf.in(w) = {}\"}</div>\n            <div style={{textIndent: 45, backgroundColor: (props.step === 7)?\"yellow\" : \"white\"}}>{\"dopredny = True\"}</div>\n            <div style={{textIndent: 30, backgroundColor: (props.step === 8)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>else if</a>{\" s == Prekroceno \"}<a style={{fontWeight: \"bold\"}}>then</a></div>\n            <div style={{textIndent: 45, backgroundColor: (props.step === 9)?\"yellow\" : \"white\"}}>{\"Graf.k(w) = Graf.k(v) + 1\"}</div>\n            <div style={{textIndent: 45, backgroundColor: (props.step === 9)?\"yellow\" : \"white\"}}>{\"Graf.in(w) = {}\"}</div>\n            <div style={{textIndent: 45, backgroundColor: (props.step === 9)?\"yellow\" : \"white\"}}>{\"B = {v}\"}</div>\n            <div style={{textIndent: 45, backgroundColor: (props.step === 9)?\"yellow\" : \"white\"}}>{\"dopredny = True\"}</div>\n            <div style={{textIndent: 30, fontWeight: \"bold\"}}>{\"end if\"}</div>\n            <div style={{textIndent: 30, backgroundColor: (props.step === 10)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>if</a>{\" dopredny && DoprednyPruzkum(Graf, w, B) \"}<a style={{fontWeight: \"bold\"}}>then</a></div>\n            <div style={{textIndent: 45, backgroundColor: (props.step === 11)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>return</a>{\" True\"}</div>\n            <div style={{textIndent: 30, fontWeight: \"bold\"}}>{\"end if\"}</div>\n            <div style={{textIndent: 15, fontWeight: \"bold\"}}>{\"end if\"}</div>\n            <div style={{textIndent: 15, backgroundColor: (props.step === 12)?\"yellow\" : \"white\"}}>{\"PridaniHrany(Graf, v, w)\"}</div>\n            <div style={{textIndent: 15, backgroundColor: (props.step === 12)?\"yellow\" : \"white\"}}><a style={{fontWeight: \"bold\"}}>return</a>{\" False\"}</div>\n        </div>\n    )\n}\n\nexport default SparseGraphPseudocode;","/Users/rumec/Documents/Škola/BP/visualization/src/components/SparseGraphSubprocedure.js",["146","147","148","149","150","151","152","153","154","155","156","157","158","159","160","161","162","163","164","165","166","167","168","169","170","171","172","173","174","175","176","177","178","179","180","181","182","183","184","185"],{"ruleId":"186","replacedBy":"187"},{"ruleId":"188","replacedBy":"189"},{"ruleId":"186","replacedBy":"190"},{"ruleId":"188","replacedBy":"191"},{"ruleId":"192","severity":1,"message":"193","line":8,"column":13,"nodeType":"194","endLine":8,"endColumn":37},{"ruleId":"195","severity":1,"message":"196","line":7,"column":49,"nodeType":"197","messageId":"198","endLine":7,"endColumn":51},{"ruleId":"186","replacedBy":"199"},{"ruleId":"188","replacedBy":"200"},{"ruleId":"186","replacedBy":"201"},{"ruleId":"188","replacedBy":"202"},{"ruleId":"203","severity":1,"message":"204","line":118,"column":22,"nodeType":"205","messageId":"206","endLine":118,"endColumn":26},{"ruleId":"203","severity":1,"message":"207","line":118,"column":35,"nodeType":"205","messageId":"206","endLine":118,"endColumn":42},{"ruleId":"186","replacedBy":"208"},{"ruleId":"188","replacedBy":"209"},{"ruleId":"210","severity":1,"message":"211","line":12,"column":99,"nodeType":"194","endLine":12,"endColumn":131},{"ruleId":"210","severity":1,"message":"211","line":12,"column":170,"nodeType":"194","endLine":12,"endColumn":202},{"ruleId":"210","severity":1,"message":"211","line":14,"column":99,"nodeType":"194","endLine":14,"endColumn":131},{"ruleId":"210","severity":1,"message":"211","line":14,"column":161,"nodeType":"194","endLine":14,"endColumn":193},{"ruleId":"210","severity":1,"message":"211","line":15,"column":99,"nodeType":"194","endLine":15,"endColumn":131},{"ruleId":"210","severity":1,"message":"211","line":16,"column":99,"nodeType":"194","endLine":16,"endColumn":131},{"ruleId":"210","severity":1,"message":"211","line":16,"column":190,"nodeType":"194","endLine":16,"endColumn":222},{"ruleId":"210","severity":1,"message":"211","line":20,"column":99,"nodeType":"194","endLine":20,"endColumn":131},{"ruleId":"210","severity":1,"message":"211","line":20,"column":163,"nodeType":"194","endLine":20,"endColumn":195},{"ruleId":"210","severity":1,"message":"211","line":26,"column":100,"nodeType":"194","endLine":26,"endColumn":132},{"ruleId":"210","severity":1,"message":"211","line":26,"column":183,"nodeType":"194","endLine":26,"endColumn":215},{"ruleId":"210","severity":1,"message":"211","line":27,"column":100,"nodeType":"194","endLine":27,"endColumn":132},{"ruleId":"210","severity":1,"message":"211","line":31,"column":100,"nodeType":"194","endLine":31,"endColumn":132},{"ruleId":"210","severity":1,"message":"211","line":8,"column":103,"nodeType":"194","endLine":8,"endColumn":135},{"ruleId":"210","severity":1,"message":"211","line":14,"column":103,"nodeType":"194","endLine":14,"endColumn":135},{"ruleId":"210","severity":1,"message":"211","line":14,"column":157,"nodeType":"194","endLine":14,"endColumn":189},{"ruleId":"210","severity":1,"message":"211","line":15,"column":103,"nodeType":"194","endLine":15,"endColumn":135},{"ruleId":"210","severity":1,"message":"211","line":16,"column":47,"nodeType":"194","endLine":16,"endColumn":79},{"ruleId":"210","severity":1,"message":"211","line":18,"column":47,"nodeType":"194","endLine":18,"endColumn":79},{"ruleId":"210","severity":1,"message":"211","line":18,"column":142,"nodeType":"194","endLine":18,"endColumn":174},{"ruleId":"210","severity":1,"message":"211","line":19,"column":103,"nodeType":"194","endLine":19,"endColumn":135},{"ruleId":"210","severity":1,"message":"211","line":19,"column":170,"nodeType":"194","endLine":19,"endColumn":202},{"ruleId":"210","severity":1,"message":"211","line":20,"column":103,"nodeType":"194","endLine":20,"endColumn":135},{"ruleId":"210","severity":1,"message":"211","line":23,"column":103,"nodeType":"194","endLine":23,"endColumn":135},{"ruleId":"210","severity":1,"message":"211","line":23,"column":157,"nodeType":"194","endLine":23,"endColumn":189},{"ruleId":"210","severity":1,"message":"211","line":24,"column":103,"nodeType":"194","endLine":24,"endColumn":135},{"ruleId":"210","severity":1,"message":"211","line":24,"column":164,"nodeType":"194","endLine":24,"endColumn":196},{"ruleId":"210","severity":1,"message":"211","line":25,"column":103,"nodeType":"194","endLine":25,"endColumn":135},{"ruleId":"210","severity":1,"message":"211","line":25,"column":161,"nodeType":"194","endLine":25,"endColumn":193},{"ruleId":"210","severity":1,"message":"211","line":26,"column":104,"nodeType":"194","endLine":26,"endColumn":136},{"ruleId":"210","severity":1,"message":"211","line":26,"column":151,"nodeType":"194","endLine":26,"endColumn":183},{"ruleId":"210","severity":1,"message":"211","line":27,"column":47,"nodeType":"194","endLine":27,"endColumn":79},{"ruleId":"210","severity":1,"message":"211","line":28,"column":47,"nodeType":"194","endLine":28,"endColumn":79},{"ruleId":"210","severity":1,"message":"211","line":29,"column":104,"nodeType":"194","endLine":29,"endColumn":136},{"ruleId":"210","severity":1,"message":"211","line":36,"column":47,"nodeType":"194","endLine":36,"endColumn":79},{"ruleId":"210","severity":1,"message":"211","line":36,"column":107,"nodeType":"194","endLine":36,"endColumn":139},{"ruleId":"210","severity":1,"message":"211","line":38,"column":47,"nodeType":"194","endLine":38,"endColumn":79},{"ruleId":"210","severity":1,"message":"211","line":38,"column":133,"nodeType":"194","endLine":38,"endColumn":165},{"ruleId":"210","severity":1,"message":"211","line":39,"column":103,"nodeType":"194","endLine":39,"endColumn":135},{"ruleId":"210","severity":1,"message":"211","line":39,"column":154,"nodeType":"194","endLine":39,"endColumn":186},{"ruleId":"210","severity":1,"message":"211","line":40,"column":103,"nodeType":"194","endLine":40,"endColumn":135},{"ruleId":"210","severity":1,"message":"211","line":41,"column":47,"nodeType":"194","endLine":41,"endColumn":79},{"ruleId":"210","severity":1,"message":"211","line":42,"column":103,"nodeType":"194","endLine":42,"endColumn":135},{"ruleId":"210","severity":1,"message":"211","line":42,"column":165,"nodeType":"194","endLine":42,"endColumn":197},{"ruleId":"210","severity":1,"message":"211","line":44,"column":103,"nodeType":"194","endLine":44,"endColumn":135},{"ruleId":"210","severity":1,"message":"211","line":44,"column":169,"nodeType":"194","endLine":44,"endColumn":201},{"ruleId":"210","severity":1,"message":"211","line":48,"column":47,"nodeType":"194","endLine":48,"endColumn":79},{"ruleId":"210","severity":1,"message":"211","line":49,"column":47,"nodeType":"194","endLine":49,"endColumn":79},{"ruleId":"210","severity":1,"message":"211","line":50,"column":47,"nodeType":"194","endLine":50,"endColumn":79},{"ruleId":"210","severity":1,"message":"211","line":51,"column":103,"nodeType":"194","endLine":51,"endColumn":135},{"ruleId":"210","severity":1,"message":"211","line":58,"column":103,"nodeType":"194","endLine":58,"endColumn":135},{"ruleId":"210","severity":1,"message":"211","line":58,"column":165,"nodeType":"194","endLine":58,"endColumn":197},{"ruleId":"210","severity":1,"message":"211","line":60,"column":47,"nodeType":"194","endLine":60,"endColumn":79},"no-native-reassign",["212"],"no-negated-in-lhs",["213"],["212"],["213"],"jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","JSXOpeningElement","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected",["212"],["213"],["212"],["213"],"no-unused-vars","'type' is assigned a value but never used.","Identifier","unusedVar","'checked' is assigned a value but never used.",["212"],["213"],"jsx-a11y/anchor-is-valid","The href attribute is required for an anchor to be keyboard accessible. Provide a valid, navigable address as the href value. If you cannot provide an href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","no-global-assign","no-unsafe-negation"]